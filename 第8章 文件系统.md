文件系统的目标是组织和保存数据。文件系统通常支持在用户和应用之间共享数据，以及数据持久化，即在重启之后数据仍然有效。

xv6文件系统提供了类Unix的文件、目录、路径名（见第1章）以及将数据保存在一个虚拟硬盘上的持久化（见第4章）。文件系统主要面临以下几个挑战：

- 文件系统需要硬盘上的数据结构用于代表有名称的目录树和文件，用于记录每个文件内容的块的身份，以及记录硬盘上哪些区域是空闲的。
- 文件系统必须支持crash恢复。就是说，如果crash（例如断电）出现，文件系统必须能够在重启后正确工作。风险在于crash可能会打断一系列的更新并遗留一些非持久的硬盘上的数据结构（例如一个块既在文件中被使用也被标记为空闲）。
- 不同进程可能同时在文件系统进行操作，所以文件系统代码必须加以协调以维持不变性。
- 访问硬盘的速度比访问内存要低几个数量级，所以文件系统必须在内存上维护一个常用块的缓存。

本章其余部分解释了xv6怎样应对这些挑战。

# 8.1 概述

文件系统必须有一个计划，在硬盘哪里存放inode和内容块。为了达到这个目标，xv6将硬盘分为几个部分，如图8.2所示。文件系统不使用block0（其中存放了boot段）。Block1叫作超级块；它包含了文件系统中的metadata（以块为单位的文件系统大小，数据块数，inode数，log中的块数）。从2开始的block存放log。log之后是inode，每个block几个inode。再之后是位图块，记录了那个数据块在使用中。其余的块是数据块；每个块都处于下面两种状态中的一种：在位图块中被标记为空闲，或者存放了文件或者目录的内容。超级块被一个单独的程序mkfs构造起来，它构造了一个初始的文件系统。

本章剩下的部分讨论了每一层，从缓冲区缓存层开始。请留意精心挑选的低层抽象是怎样简化高层代码的。

# 8.2 缓冲区缓存层

缓冲区缓存有两个任务：（1）同步对硬盘块的访问，从而保证在内存中一个块只有一份拷贝，而且同一时间内只有一个内核线程使用这个拷贝；（2）缓存常用的块，这样使用它们时就不必从缓慢的硬盘里再次读取。代码位于bio.c。

缓冲区缓存层暴露的主要接口有bread与bwrite构成；前者获取一段包含一个块的拷贝的buffer，能够在内存中读取或改动，后者将一段改动过的buffer写入到硬盘上合适的块。内核线程操作完成后必须通过调用brelse释放buffer。缓冲区缓存层使用一个每buffer的睡眠锁来保证同一时间只有一个线程使用一个buffer（也因此使用一个硬盘块）；bread返回一个加锁的buffer，brelse释放这个buffer。

我们回到缓冲区缓存。缓冲区缓存层有一个固定数量的buffer来保存内存块，这意味着如果文件系统请求一个不在缓存中的块，缓冲区缓存层必须马上回收一个当前持有其他块信息的buffer。缓冲区缓存回收近期使用最少的buffer来保存新块。其中包含的假设是，近期使用最少的buffer是近期再次被使用可能性最小的。

# 8.3 代码：缓冲区缓存

buffer缓存是一个buffer的双链表。main（kernel/main.c:27）调用的binit函数使用静态数组buf（kernel/bio.c:46-52）中的NBUF个buffer初始化链表。所有其他对缓冲区缓存的访问都是通过bcache.head访问链表，而不是buf数组。

buffer有两个与它相关的状态域。
