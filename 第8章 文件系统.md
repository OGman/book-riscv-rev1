文件系统的目标是组织和保存数据。文件系统通常支持在用户和应用之间共享数据，以及数据持久化，即在重启之后数据仍然有效。

xv6文件系统提供了类Unix的文件、目录、路径名（见第1章）以及将数据保存在一个虚拟硬盘上的持久化（见第4章）。文件系统主要面临以下几个挑战：

- 文件系统需要硬盘上的数据结构用于代表有名称的目录树和文件，用于记录每个文件内容的块的身份，以及记录硬盘上哪些区域是空闲的。
- 文件系统必须支持crash恢复。就是说，如果crash（例如断电）出现，文件系统必须能够在重启后正确工作。风险在于crash可能会打断一系列的更新并遗留一些非持久的硬盘上的数据结构（例如一个块既在文件中被使用也被标记为空闲）。
- 不同进程可能同时在文件系统进行操作，所以文件系统代码必须加以协调以维持不变性。
- 访问硬盘的速度比访问内存要低几个数量级，所以文件系统必须在内存上维护一个常用块的缓存。

本章其余部分将解释xv6怎样应对这些挑战。

# 8.1 概述

xv6文件系统实现组织为7层，如图8.1所示。硬盘层在virtio硬件驱动上读写块。缓冲区缓存层缓存了硬盘块，并且同步对它们的访问，保证同一时间内只有一个内核进程可以修改保存在任何特定块内的数据。日志层允许更高的层将对几个块的修改打包在一次传输中，保证遇到crash时以原子方式更新这些块（即所有的要么都更新了要么都没更新）。inode层提供了单独的文件，每个文件由一个有着唯一的i-编号，并包含一些持有文件数据的块的inode表示。目录层将每个目录实现为一种特殊的inode，inode的内容是一系列的目录项，每个目录项包含了一个文件的名称和i-number。路径名层提供了层次式的路径名例如/usr/rtm/xv6/fs.c，并且使用递归查找解析它们。文件描述符层使用文件系统接口抽象了很多Unix资源（例如，管道，设备，文件等等），让应用程序员的生活更容易。

文件系统必须有一个计划，在硬盘哪里存放inode和内容块。为了达到这个目标，xv6将硬盘分为几个部分，如图8.2所示。文件系统不使用block0（其中存放了boot段）。Block1叫作超级块；它包含了文件系统中的metadata（以块为单位的文件系统大小，数据块数，inode数，log中的块数）。从2开始的block存放log。log之后是inode，每个block几个inode。再之后是位图块，记录了那个数据块在使用中。其余的块是数据块；每个块都处于下面两种状态中的一种：在位图块中被标记为空闲，或者存放了文件或者目录的内容。超级块被一个单独的程序mkfs构造起来，它构造了一个初始的文件系统。

本章剩下的部分讨论了每一层，从缓冲区缓存层开始。请留意精心挑选的低层抽象是怎样简化高层代码的。

# 8.2 缓冲区缓存层

缓冲区缓存有两个任务：（1）同步对硬盘块的访问，从而保证在内存中一个块只有一份拷贝，而且同一时间内只有一个内核线程使用这个拷贝；（2）缓存常用的块，这样使用它们时就不必从缓慢的硬盘里再次读取。代码位于bio.c。

缓冲区缓存层暴露的主要接口有bread与bwrite构成；前者获取一段包含一个块的拷贝的buffer，能够在内存中读取或改动，后者将一段改动过的buffer写入到硬盘上合适的块。内核线程操作完成后必须通过调用brelse释放buffer。缓冲区缓存层使用一个每buffer的睡眠锁来保证同一时间只有一个线程使用一个buffer（也因此使用一个硬盘块）；bread返回一个加锁的buffer，brelse释放这个buffer。

我们回到缓冲区缓存。缓冲区缓存层有一个固定数量的buffer来保存内存块，这意味着如果文件系统请求一个不在缓存中的块，缓冲区缓存层必须马上回收一个当前持有其他块信息的buffer。缓冲区缓存回收近期使用最少的buffer来保存新块。其中包含的假设是，近期使用最少的buffer是近期再次被使用可能性最小的。

# 8.3 代码：缓冲区缓存

buffer缓存是一个buffer的双链表。main（kernel/main.c:27）调用的binit函数使用静态数组buf（kernel/bio.c:46-52）中的NBUF个buffer初始化链表。所有其他对缓冲区缓存的访问都是通过bcache.head访问链表，而不是buf数组。

buffer有两个与它相关的状态域。valid域表示buffer包含了一个块的拷贝。disk域表示buffer内容已经被提交给硬盘，这会修改buffer（例如，从硬盘向data写数据）。

bread（kernel/bio.c:93）调用bget来为给定的分段获取buffer（kernel/bio.c:97）。如果buffer需要从硬盘读取，在返回buffer前，bread调用virtio_disk_rw来做这件事。

bget（kernel/bio.c:59）使用给定的设备和分段号在buffer链表中寻找buffer（kernel/bio.c:65-73）。如果有这样的buffer，bget获取buffer的睡眠锁，然后返回加锁的buffer。

如果没有给定分段的已缓存的buffer，bget必须制造一个，可能会使用一个持有别的分段的buffer。它第二次扫描buffer链表，看看有没有未使用的buffer（b->refcnt == 0）；任何一个这样的buffer都可以被使用。bget编辑buffer的metadata来记录新的设备和分段编号，然后获取它的睡眠锁。请注意b->valid = 0的赋值保证了bread能够从磁盘中读取块数据而不是错误地使用buffer中之前的内容。

每个磁盘分段最多只有一个缓存的buffer，这一点很重要，这保证了读者能够看到写入。实现这一点是因为文件系统在buffer上使用锁来同步。bget从第一个循环检查块是否被缓存开始，直到第二个循环声明块现在已经缓存为止，一致持有bache.lock，从而保证了这个不变性。这使得检查块的存在和（如果不存在的话）buffer持有块的设计成为原子的。

bget在bcache.lock的临界区外获取buffer的睡眠锁是安全的，因为非0的b->refcnt值保护了buffer不被别的硬盘块重用。睡眠锁保护了这个块的缓冲区内容的读写，而bcache.lock保护了关于缓存的是哪个块的信息。

如果所有的buffer都在使用中，那么同一时间执行操作系统调用的进程就太多了；这会造成bget panic。一种更优雅的回应可能是睡眠到有空闲buffer的时候，尽管这样可能会有死锁的可能性。

一旦bread读取了磁盘（如果需要）而且将buffer返回给了它的调用者，调用者就有了排他的buffer使用权，可以读写数据字节。如果调用者修改了buufer，它必须调用bwrite，在释放buffer之前将修改的数据写入到磁盘中。bwrite（kernel/bio.c:107）调用virtio_disk_rw来向硬盘硬件发送消息。

调用者用完buffer后，必须调用brelse来释放它。（brelse的名字是b-release的简写，晦涩难懂但值得一读：它最早出现在Unix中，后来在BSD、Linux、Solaris中都有使用。）Brelse（kernel/bio.c:117）释放睡眠锁，将buffer移动到链表前端（kernel/bio.c:128-133）。移动buffer使得链表按照被使用（释放）时间的早晚排列：链表中的第一个buffer是最近使用的，最后一个是最近使用最少的。bget中的两个循环利用了这一点：查找已存在的buffer在最坏情况下必须完整地遍历链表，但先（从bcache.head开始，顺着next指针遍历）查看最近使用的buffer会缩短查找时间。对重用buffer的挑选选的是近期使用最少的buffer，通过逆向查找链表获得（沿着prev指针）。

cryptic
