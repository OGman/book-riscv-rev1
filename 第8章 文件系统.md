文件系统的目标是组织和保存数据。文件系统通常支持在用户和应用之间共享数据，以及数据持久化，即在重启之后数据仍然有效。

xv6文件系统提供了类Unix的文件、目录、路径名（见第1章）以及将数据保存在一个虚拟硬盘上的持久化（见第4章）。文件系统主要面临以下几个挑战：

- 文件系统需要硬盘上的数据结构用于代表有名称的目录树和文件，用于记录每个文件内容的块的身份，以及记录硬盘上哪些区域是空闲的。
- 文件系统必须支持crash恢复。就是说，如果crash（例如断电）出现，文件系统必须能够在重启后正确工作。风险在于crash可能会打断一系列的更新并遗留一些非持久的硬盘上的数据结构（例如一个块既在文件中被使用也被标记为空闲）。
- 不同进程可能同时在文件系统进行操作，所以文件系统代码必须加以协调以维持不变性。
- 访问硬盘的速度比访问内存要低几个数量级，所以文件系统必须在内存上维护一个常用块的缓存。

本章其余部分将解释xv6怎样应对这些挑战。

# 8.1 概述

xv6文件系统实现组织为7层，如图8.1所示。硬盘层在virtio硬件驱动上读写块。缓冲区缓存层缓存了硬盘块，并且同步对它们的访问，保证同一时间内只有一个内核进程可以修改保存在任何特定块内的数据。日志层允许更高的层将对几个块的修改打包在一次传输中，保证遇到crash时以原子方式更新这些块（即所有的要么都更新了要么都没更新）。inode层提供了单独的文件，每个文件由一个有着唯一的i-编号，并包含一些持有文件数据的块的inode表示。目录层将每个目录实现为一种特殊的inode，inode的内容是一系列的目录项，每个目录项包含了一个文件的名称和i-number。路径名层提供了层次式的路径名例如/usr/rtm/xv6/fs.c，并且使用递归查找解析它们。文件描述符层使用文件系统接口抽象了很多Unix资源（例如，管道，设备，文件等等），让应用程序员的生活更容易。

文件系统必须有一个计划，在硬盘哪里存放inode和内容块。为了达到这个目标，xv6将硬盘分为几个部分，如图8.2所示。文件系统不使用block0（其中存放了boot段）。Block1叫作超级块；它包含了文件系统中的metadata（以块为单位的文件系统大小，数据块数，inode数，log中的块数）。从2开始的block存放log。log之后是inode，每个block几个inode。再之后是位图块，记录了那个数据块在使用中。其余的块是数据块；每个块都处于下面两种状态中的一种：在位图块中被标记为空闲，或者存放了文件或者目录的内容。超级块被一个单独的程序mkfs构造起来，它构造了一个初始的文件系统。

本章剩下的部分讨论了每一层，从缓冲区缓存层开始。请留意精心挑选的低层抽象是怎样简化高层代码的。

# 8.2 缓冲区缓存层

缓冲区缓存有两个任务：（1）同步对硬盘块的访问，从而保证在内存中一个块只有一份拷贝，而且同一时间内只有一个内核线程使用这个拷贝；（2）缓存常用的块，这样使用它们时就不必从缓慢的硬盘里再次读取。代码位于bio.c。

缓冲区缓存层暴露的主要接口有bread与bwrite构成；前者获取一段包含一个块的拷贝的buffer，能够在内存中读取或改动，后者将一段改动过的buffer写入到硬盘上合适的块。内核线程操作完成后必须通过调用brelse释放buffer。缓冲区缓存层使用一个每buffer的睡眠锁来保证同一时间只有一个线程使用一个buffer（也因此使用一个硬盘块）；bread返回一个加锁的buffer，brelse释放这个buffer。

我们回到缓冲区缓存。缓冲区缓存层有一个固定数量的buffer来保存内存块，这意味着如果文件系统请求一个不在缓存中的块，缓冲区缓存层必须马上回收一个当前持有其他块信息的buffer。缓冲区缓存回收近期使用最少的buffer来保存新块。其中包含的假设是，近期使用最少的buffer是近期再次被使用可能性最小的。

# 8.3 代码：缓冲区缓存

buffer缓存是一个buffer的双链表。main（kernel/main.c:27）调用的binit函数使用静态数组buf（kernel/bio.c:46-52）中的NBUF个buffer初始化链表。所有其他对缓冲区缓存的访问都是通过bcache.head访问链表，而不是buf数组。

buffer有两个与它相关的状态域。valid域表示buffer包含了一个块的拷贝。disk域表示buffer内容已经被提交给硬盘，这会修改buffer（例如，从硬盘向data写数据）。

bread（kernel/bio.c:93）调用bget来为给定的分段获取buffer（kernel/bio.c:97）。如果buffer需要从硬盘读取，在返回buffer前，bread调用virtio_disk_rw来做这件事。

bget（kernel/bio.c:59）使用给定的设备和分段号在buffer链表中寻找buffer（kernel/bio.c:65-73）。如果有这样的buffer，bget获取buffer的睡眠锁，然后返回加锁的buffer。

如果没有给定分段的已缓存的buffer，bget必须制造一个，可能会使用一个持有别的分段的buffer。它第二次扫描buffer链表，看看有没有未使用的buffer（b->refcnt == 0）；任何一个这样的buffer都可以被使用。bget编辑buffer的metadata来记录新的设备和分段编号，然后获取它的睡眠锁。请注意b->valid = 0的赋值保证了bread能够从磁盘中读取块数据而不是错误地使用buffer中之前的内容。

每个磁盘分段最多只有一个缓存的buffer，这一点很重要，这保证了读者能够看到写入。实现这一点是因为文件系统在buffer上使用锁来同步。bget从第一个循环检查块是否被缓存开始，直到第二个循环声明块现在已经缓存为止，一致持有bache.lock，从而保证了这个不变性。这使得检查块的存在和（如果不存在的话）buffer持有块的设计成为原子的。

bget在bcache.lock的临界区外获取buffer的睡眠锁是安全的，因为非0的b->refcnt值保护了buffer不被别的硬盘块重用。睡眠锁保护了这个块的缓冲区内容的读写，而bcache.lock保护了关于缓存的是哪个块的信息。

如果所有的buffer都在使用中，那么同一时间执行操作系统调用的进程就太多了；这会造成bget panic。一种更优雅的回应可能是睡眠到有空闲buffer的时候，尽管这样可能会有死锁的可能性。

一旦bread读取了磁盘（如果需要）而且将buffer返回给了它的调用者，调用者就有了排他的buffer使用权，可以读写数据字节。如果调用者修改了buufer，它必须调用bwrite，在释放buffer之前将修改的数据写入到磁盘中。bwrite（kernel/bio.c:107）调用virtio_disk_rw来向硬盘硬件发送消息。

调用者用完buffer后，必须调用brelse来释放它。（brelse的名字是b-release的简写，晦涩难懂但值得一读：它最早出现在Unix中，后来在BSD、Linux、Solaris中都有使用。）Brelse（kernel/bio.c:117）释放睡眠锁，将buffer移动到链表前端（kernel/bio.c:128-133）。移动buffer使得链表按照被使用（释放）时间的早晚排列：链表中的第一个buffer是最近使用的，最后一个是最近使用最少的。bget中的两个循环利用了这一点：查找已存在的buffer在最坏情况下必须完整地遍历链表，但先（从bcache.head开始，顺着next指针遍历）查看最近使用的buffer会缩短查找时间。对重用buffer的挑选选的是近期使用最少的buffer，通过逆向查找链表获得（沿着prev指针）。

cryptic

# 8.4 日志层

crash恢复是文件系统设计中最有意思的问题之一。如果很多文件系统操作都包含向硬盘写数据，其中一部分写入刚完成时发生了crash，这将使硬盘上的文件系统处于一种不确定的状态。举例来说，假设crash发生在文件截断时（将文件长度设为0,并释放它包含的块），由于硬盘的写入顺序不同，可能出现以下情况：可能会将一个包含有内容块的inode标记为free，或者可能留下一个已分配但未引用的有内容块。

后面的情况相对温和，但前者很可能会在重启后造成严重的问题。重启后，内核可能将块分配给其他文件，这是我们就有了两个文件无意中指向同一个块。如果xv6支持多用户，这种情况就可能变成一个安全问题，因为老文件的拥有者可能可以读写新文件上的块，而这个新文件是其他用户所拥有的。

xv6使用一种简单的日志方式解决了文件系统操作中的crash问题。xv6系统调用并不直接写硬盘上的文件系统数据结构。取而代之的是，它将所有需要的磁盘操作描述在一个硬盘上的日志中。一旦系统调用记录了它的所有写入，它会给硬盘提交一个特殊的记录，表明这些日志包含了一个完整的操作。这是系统调用才将写入操作拷贝到硬盘上文件系统数据结构中。所有这些写入完成后，系统调用会把所有的日志擦除。

如果系统crash后重启，操作系统在运行任何进程之前，按下列方式从crash恢复。如果日志被标记为包含完整操作，恢复代码就把写操作拷贝到硬盘上文件系统它们本应该在的位置。如果日志没有被标记为包含完整操作，恢复代码就忽略掉这个日志。恢复代码以擦除日志结尾。

为什么xv6的log解决了文件系统操作过程中的crash问题？如果crash发生在操作提交之前，硬盘log就不会被标记为完整，恢复代码会忽略它，这样硬盘的状态就好像操作并没开始。如果crash在操作提交之后发生，恢复代码将会重新执行所有写入操作，有可能是之前已经开始写入也要重复写一遍。两种情况下，日志都将crash下的操作变成了原子操作：恢复后，要么所有的操作都已在硬盘上写好，要么所有操作都没发生。

inconsistent    truncation    benign    unintentionally    with respect to

# 8.5 日志设计

日志位于已知的固定位置，指定在超级块中。它由一个头块和后面的一系列更新块拷贝（“日志块”）组成。头部块包含日志块数以及一个分段数数组，每个元素对应一个日志块。硬盘上的头部块尺寸数要么就是0，表示log中没有事务，要么就是非0，表示log包含一个完整的提交的事务，包含在指定数目的日志块中。xv6在事务提交时而不是之前写入头部块，而且在将日志块拷贝到文件系统后将count设为0。因此提交中途发生的crash会导致日志的头部块中count为0,；发生在提交后的crash会产生一个非0的count。

每个系统调用的代码说明了对于crash是原子操作的写操作序列的开始和结束。为了允许不同进程同时执行文件系统操作，日志系统可以将多个系统调用中的写操作积累在一个事务中。因此一个提交可能包含多个完整的系统调用中的写操作。为了避免将一个系统调用划分到不同的事务中，日志系统仅在没有文件系统系统调用进行时提交事务。

多个事务一起提交的思想被称为组提交。组提交减少了硬盘操作的次数，因为它在多个操作之间分摊了提交的固定开销。组提交也让硬盘系统能够同时处理更多的并发写入，可能允许硬盘在一个硬盘转动中完成所有的写入操作。xv6的virtio驱动不支持这类批处理，但xv6的文件系统设计允许这一点。

xv6使用硬盘上的固定尺寸的空间来保存log。系统调用一次事务中写入的总块数必须能放在那个空间中。这导致了两个结果。首先，没有单个系统调用可以写入超过日志剩余空间的块。这对大多数系统调用来说都没问题，但有两个系统调用可能会写大量的块：write和unlink。一个大文件的写入可能写很多数据块，很多位图块以及一个inode块；释放一个大文件的连接可能写很多位图块和一个inode。xv6的write系统调用将大量的写入分割为多个小型的适合log的写入，unlink不会引发问题，因为实际上xv6的文件系统只使用一个位图块。其次，有限的log空间使得log系统不允许一个系统调用在不确定日志剩余空间是否能容纳其写入的情况下开始。

transaction    underway   amortize    batch   dedicate    distinct

# 8.6 代码：写日志

系统调用使用日志的典型用法如下：

```C
begin_op();
...
bp = bread();
bp->data[...] = ...;
log_write(bp);
...
end_op();
```


