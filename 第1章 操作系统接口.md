操作系统的工作，一个是在不同程序之间共享计算机，一个是提供比硬件所提供的的服务更好用的服务集合。操作系统管理并抽象底层硬件，因此，举例来说，文字处理器不需要考虑自己用的是什么类型的硬盘硬件。操作系统将硬件在多个程序之间分享，让它们能同时运行（或看起来是同时运行）。最后，操作系统为程序间的交互提供受控的方法，这样它们就能共享数据或协同工作。

操作系统通过接口向用户进程提供服务。设计一套好的接口很难。一方面，我们希望接口简单而狭窄，因为这样的接口容易正确地使用。另一方面，我们可能尝试为应用程序提供很多复杂的特性。解决这个矛盾的方法，是设计依赖于一些机制的接口，它们可以组合起来，提供更通用的功能。

本书使用一个简单的操作系统作为具体的例子，来阐述操作系统的概念。xv6操作系统提供了Ken Thompson与Dennis Ritchie的Unix操作系统引入的基础接口[14]，以及模仿Unix的内部实现。Unix提供了一组狭窄的接口，其机制可以很好地结合，从而提供了令人惊讶的通用性。这组接口相当成功，现代操作系统——BSD，Linux，MAC OS X，Solarias，甚至较低程度地，Microsoft Windows——都有类Unix接口。理解xv6对于理解这些操作系统中的任何一种以及很多其他的系统来说，是一个很好地开始。

如图1.1所示，xv6延续了内核的传统，内核是一个特殊的程序，它为程序运行提供了服务。运行的程序叫做进程，有着包含指令、数据和一个栈的内存。指令实现了程序的计算。数据是计算中所使用的变量。栈组织了程序的调用过程。典型地，一台给定的计算机有很多进程，但只有一个内核。

当进程需要调用内核服务时，它调用一个系统调用，操作系统接口中的一种。系统调用进入到内核；内核执行对应的服务并返回。因此，进程在用户空间和内核空间之间切换。

内核使用CPU提供的硬件保护机制来保证每个运行在用户空间的进程只能访问它自己的内存。内核以实现这些保护所需要的硬件特权执行；用户程序没有这些特权。当用户程序调用系统调用时，硬件提升其特权级别，开始执行内核中提前安排好的函数。

内核提供的系统调用的集合是用户程序所看到的接口。xv6提供了Unix内核传统上提供的系统调用的一个子集。图1.2列出了所有的xv6系统调用。

本章其余部分简要描述了xv6提供的服务——进程、内存、文件描述符、管道以及一个文件系统——并使用代码片段举例说明了它们，还讨论了shell（Unix的命令行用户界面）如何使用它们。shell对系统调用的使用说明了系统调用的设计是多么仔细。

shell是一个普通程序，它从用户读取命令并执行。shell是用户程序而非内核一部分的事实说明了系统调用接口的强大：shell没什么特别的。它也说明，shell很容易被取代；这就造成现代Unix系统有大量可选的shell，每种shell都有自己的用户界面和脚本特性。xv6 shell是Unix Bourne shell精髓部分的简单实现。它的实现可以在（user/sh.c:1）中找到。

snippet

# 1.1 进程和内存

xv6进程由用户空间内存（指令、数据、栈）和内核私有的每进程状态组成。xv6时间共享进程：它在等待执行的进程集合中透明地切换可用的CPU。当进程没运行时，xv6将它的CPU寄存器保存，下次运行这个进程时恢复。内核用进程标识符，或者叫PID标识每个进程。

进程可能使用fork系统调用创建新进程。fork使用调用它的进程，即父进程的相同内存内容创建新进程，叫作子进程。fork在父进程和子进程中都返回。在父进程中，fork返回子进程的PID；在进程中则返回0。举例个例子，考虑下面的C语言程序片段：

```C
int pid = fork();
if (pid > 0) {
    printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if (pid == 0) {
    printf("child: exiting\n");
    exit(0);
} else {
    printf("fork error\n");
}
```

exit系统调用使调用进程停止执行并释放资源，例如内存和打开的文件。exit使用一个整型状态参数，通常用0表示成功，1表示失败。wait系统调用返回一个当前进程的退出（或被杀）的子进程的PID，并将子进程的退出状态拷贝到传给wait的地址上；如果调用者没有进程退出，wait会等到有子进程退出。如果调用者没有子进程，wait直接返回-1。如果父进程不在乎子进程的退出状态，它可以给wait传入0地址。

在这个例子中，输出行：

```
parent: child=1234
child: exiting
```

的先后顺序可能是任意一种，取决于父进程与子进程谁先到达printf调用。在子进程退出后，父进程的wait返回，导致父进程打印：

```
parent: child 1234 is done
```

尽管最开始子进程的内存内容与父进程相同，但父进程与子进程其实运行在不同的内存中，使用不同的寄存器：改变其中一个的变量不会影响到另一个。举例来说，当wait的返回值存放在父进程的pid中时，它并不会改变子进程中pid的值。子进程中pid的值仍然为0。

exec系统调用用一个新的内存镜像替换掉调用进程的内存，新内存来自于文件系统中保存的一个文件。文件必须有一个特殊的格式，它指定了文件的哪部分存放指令，哪部分存放数据，从哪条指令开始，等等。xv6使用ELF格式，第3章会详细讨论。当exec执行成功，它不会返回到调用程序中；从文件中加载的指令会在ELF头中声明的入口点处开始执行。exec有两个参数：可执行文件的文件名和一个字符串变量数组。例如：

```C
char *argv[3];

argv[0] = "echo";
argv[1] = "helloc";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec erorr\n");
```
这段代码用使用参数列表echo hello的程序实例/bin/echo替换了调用程序。大部分程序忽略参数数组中的第一个元素，通常是程序名。

xv6 shell使用上面的调用为用户运行程序。shell的主要结构很简单；见main（user/sh.c:145）。主循环使用getcmd从用户输入读取一行。然后调用fork，创建一个shell进程的拷贝。当子进程运行命令时，父进程调用wait。例如，如果用户在shell中输入“echo hello”，runcmd会以“echo hello”为参数被调用。runcmd（user/sh.c:58）运行实际的命令。对“echo hello”来说，它会调用exec（user/sh.c:78）。如果exec成功，子进程将执行echo中的指令而不是runcmd。在某些时候echo会调用exit，使父进程从main中的wait函数返回（user/sh.c:145）。

你可能会好奇为什么fork与exec没有合并在一个调用中；我们在后面会看到，shell在其I/O重定向的实现中利用了这种分离。为避免创建一个复制的进程然后直接替换掉它（用exec）所带来的浪费，系统内核优化了这种情况下fork的实现，在fork中使用了虚拟内存技术例如写时拷贝（见4.6）。

xv6显式地分配大部分用户空间内存：fork分配子进程所需的用于拷贝父进程内存的内存，然后exec分配足够的空间用于存放可执行文件。运行时需要更多内存（可能用于malloc）的进程可以调用sbrk(n)来增长n字节的数据内存；sbrk返回新内存的地址。

# 1.2 I/O与文件描述符

文件描述符是代表一个进程可能读写的内核管理的对象的小整数。进程可能通过打开文件、目录或设备，或者创建管道，亦或复制已存在的描述符来获得。简单起见，我们将把文件描述符指向的对象称为“文件”；文件描述符接口的抽象隔离了文件、管道和设备之间的不同，让它们看起来都好像是字节流。我们将把输入输出称为I/O。

在内部，xv6内核将文件描述符作为每进程表的索引来使用，这样每个进程都有了一个从0开始的私有文件描述符空间。传统上，进程从文件描述符0读取（标准输入），向文件描述符1写入（标准输出），将错误消息写入文件描述符2（标准错误）。如我们所见，shell利用这个传统来实现I/O重定向与管道。shell保证有三个文件描述符一直打开（user/sh.c：151），它们就是默认的控制台文件描述符。

read和write系统调用从文件描述符所指的打开的文件读取和写入数据。read(fs, buf, n)调用从文件描述符中读取最多n个字节，将它们拷贝到buf中，然后返回读到的字节数。每个指向一个文件的文件描述符都有一个与它对应的偏移量。read从当前的文件偏移读取数据，然后将偏移量增加读取的字节数：后续的read将返回第一个read返回的数据后面的字节。当没有更多字节可以读取时，read返回0来说明文件已到结尾。

write(fs, buf, n)调用将buf中的n个字节写入到文件描述符fs中，然后返回写入的字节数。出错时写入的字节数将小于n。跟read一样，write在当前文件偏移处写入数据，然后将偏移量后移写入的字节数：每个write都在上一个write离开的地方继续。

后面这段代码（组成了cat程序的必要部分）将数据从它的标准输入拷贝到标准输出。如果出现错误，它会在标准错误中写入一条消息。

```C
char buf[512];
int n;

for (;;) {
    n = read(0, buf, sizeof buf);
    if (n == 0)
        break;
    if (n < 0) {
        fprintf(2, "read error\n");
        exit(1);
    }
    if (write(1, buf, n) != n) {
        fprintf(2, "write error\n");
        exit(1);
    }
}
```

其中需要注意的重点是cat不知道它是从哪里读数据的，是文件，控制台还是管道。同样，cat不知道它打印在控制台还是文件，还是别的什么地方。文件描述符的使用和文件描述符0是输入，1是输出的传统使得cat的实现非常简单。


