操作系统通过页表为每一个进程提供了它自己的私有地址空间和内存。页表决定了内存地址表示什么，也决定了哪部分物理地址可以被访问。它们允许xv6将不同进程的地址空间隔离开来，并将他们复用到同一物理内存上。页表提供了一个间接层，让xv6能玩一些小花招：将同一段内存（跳板页）映射到不同的地址空间，使用未映射的页来保护内核和用户栈。本章中其他部分解释了RISC-V硬件所提供的页表，以及xv6如何使用它们。

# 3.1 分页硬件

提醒一下，RISC-V指令（包括用户和内核）使用虚拟地址。而机器的RAM，或物理内存，使用物理地址进行索引。RISC-V页表硬件连接这两种地址，将虚拟地址映射到物理地址。

xv6运行在Sv39 RISC-V上，这表示在64位虚拟地址中，只使用了低39位，而高25位未使用。在这种Sv39配置中，RISC-V页表逻辑上是一个包含2^27（134,217,728）个页表项（PTE，page table entry）的向量表。每个PTE包含一个44位物理页编码（PPN，physical page number）和一些标志位。分页硬件使用39位虚拟地址中的高27位作为索引，在页表中找到对应的PTE，然后用PTE中的44位地址作为高位，虚拟地址中的低12位作为地位，构造出一个56位的物理地址。图3.1展现了这个过程，其中页表按照逻辑理解，被描绘为一个PTE构成的向量表（图3.2给出了真实情况）。页表给予了操作系统控制虚拟地址到物理地址翻译的能力。内存的粒度大小是4096（2^12）的对齐块。这种块叫作页。

在Sv39 RISC-V中，高25位没有参与到地址转换中；未来RISC-V可能会使用这些位定义更多层的地址转换。物理地址也还有增加的空间：PTE格式中的物理页编号仍有增长10位的空间。

如图3.2，实际的地址转换分为三步。页表以三层树的结构保存在物理内存中。树的根是一张4096字节的页表，包含512PTE，每个PTE都包含了下一层页表存放页的物理地址。这些页中包含了512PTE，保存树的最终层。分页硬件使用27位中的高9位查找根页表中的PTE，中9位查找中层页表中的PTE，低9位查找最终PTE。

翻译地址时，如果所需要的三个PTE中有任意一个不存在，分页硬件都会产生一个分页错误异常，让内核去处理这个异常（参见第四章）。这个三层结构让页表无需存放完整的页表，因为大段的虚拟地址没有映射是非常常见的情况。

每个PTE都包含标志位，用来告诉分页硬件，关联的页允许怎样使用。PTE_V表示PTE是否存在：如果没设置它，对这个页的引用会产生异常（即不允许）。PTE_R控制是否允许指令读这个页。PTE_W控制是否允许指令写这个页。PTE_X决定CPU是否能将页中国的内容解释为指令并运行它们。PTE_U控制是否允许用户模式下的指令访问这个页；如果未设置PTE_U，PTE只能在管理者模式下使用。图3.2描绘了它的工作方法。这些标志位和所有其他与分页硬件相关的结构体都定义在（kernel/riscv.h）中。

为了让硬件使用页表，内核必须将根页表页的物理地址写入satp寄存器中。每个CPU都有它自己的satp。CPU会将后续所有指令产生的地址都使用它satp中所存放的页表进行翻译。每个CPU拥有自己的satp寄存器，所以不同的CPU可以运行不同的进程，每个进程都有用它自己的页表描述的私有的地址空间。

一些名词需要解释一下。物理内存指的是DRAM中的存储单元。每一字节的物理内存都有一个地址，叫物理地址。指令只使用虚拟地址，分页硬件将虚拟地址翻译成物理地址，然后发送给DRAM硬件来读取或写入存储。虚拟内存不像物理内存和虚拟地址那样，它不是物理实体。它指的是内核提供的用来管理物理内存和虚拟地址的抽象和机制的集合。

# 3.2 内核地址空间

xv6为每个进程维护一张页表，用来描述进程的用户地址空间。为内核也维护了一张页表，用于描述内核地址空间。内核注册了这个地址空间的布局，来为自己提供在已知虚拟地址上访问物理内存和各种硬件资源的便利。图3.3展现了这个布局如何将内核虚拟地址映射到物理地址上。文件 (kernel/memlayout.h)声明了xv6内核内存布局的各种常量。

QEMU模拟了一台计算机，它的RAM（物理内存）从物理地址0x80000000开始，一直到至少0x86400000才结束，结束点在xv6中称为PHYSTOP。QEMUdemonic也包括硬盘接口之类的I/O设备。QEMU将设备接口以映射在内存的控制寄存器的形式暴露给软件，它们的位于0x80000000之前的物理地址空间。内核能够通过读/写这些特殊物理地址的方式与设备交互；这些读写操作直接与设备硬件通信，而不是RAM。第四章解释了xv6怎样与设备交互。

内核使用“直接映射”来获取RAM与应设在内存上的设备寄存器。直接映射就是说，将资源映射在与物理地址相同的虚拟地址上。举例来说，内核本身在虚拟地址和物理地址上都位于KERNBASE=0x80000000。直接映射简化了读写物理内存的内核代码。例如，当fork为子进程分配用户内存时，分配器返回内存的物理地址；当fork将父进程的用户内存拷贝给子进程时，直接使用这个地址作为虚拟地址。

有一些内核虚拟地址没有被直接映射：

- 跳板页。跳板页被映射在虚拟地址空间的顶部；用户页表也有同样的映射。第4章讨论了跳板页扮演的角色，但我们这里只把它看成是一种有趣的页表使用实例；物理页（包含跳板代码）在内核虚拟地址空间中被映射了两次：一次在虚拟地址空间的顶部，一次是直接映射。

- 内核栈页。每个进程都有自己的内核栈，映射在高地址，以便xv6能在它下面放置一个未映射的保护页。保护页的PTE是无效的（比方说PTE_V未设置），因此当内核栈溢出时，有可能引起异常，内核将报错。没有保护页的话，溢出的栈将覆盖别的内核内存，造成运行错误。内核报错是更好的结果。

当内核通过高位内存映射使用内核栈时，这些栈也可以被内核通过直接映射的地址使用。另一种设计可能是只使用直接映射，在直接映射的地址使用栈。然而，在这种设计中，提供保护页必须包括取消它的虚拟地址映射，否则将映射到物理内存，这使用起来将会很麻烦。

内核给映射跳板页和内核代码的页PTE_R与PTE_X权限，因为内核需要读取并运行这些页上的指令。对映射的其他页赋予PTE_R与PTE_W权限，从而能够读写这些页上的内存。保护页的映射是无效的。

# 3.3 代码：创建地址空间

xv6中，大部分操作地址空间和页表的代码都位于vm.c（kernel/vm.c:1）中。其中核心的数据结构是pagetable_t，是一个指向RISC-V根页表页的指针；一个pagetable_t可能是内核页表，也可能是一个进程页表。核心函数有：walk，按照虚拟地址找到PTE；mappages，为新的映射安装PTE。以kvm开头的函数用来操作内核页表；以uvm开头的函数操作用户页表；其他的函数两者都可以用。copyout函数向用户虚拟地址拷贝数据，copyin则从用户虚拟地址拷贝数据到内核，并作为系统调用的参数；因为它们需要显式地翻译这些地址为对应的物理地址，所以它们也放在vm.c中。

在boot流程的早期，main调用kvminit（kernel/vm.c:22）来创建内核页表。这个调用发生时，xv6还不能在RISC-V上分页，所以地址直接指向物理内存。Kvminit首先分配一页物理内存来存放根页表页。然后ta调用kvmmap来安装内核需要的翻译。翻译包括内核的指令和数据，到PHYSTOP的物理地址，以及实际是设备的内存段。

kvmmap（kernel/vm.c:118）调用mappages（kernel/vm.c:149）向一个页表安装从一段虚拟地址向对应的物理地址的映射。它以页大小为间隔，为地址段中每个虚拟地址分别执行此操作。对每个需要映射的虚拟地址，mappages调用walk来找到对应该地址的PTE位置。然后它初始化这个PTE来存放对应的物理页编号，需要的权限（PTE_W，PTE_X，PTE_R），用PTE_V标记PTE是否可用（kernel/vm:161）。

walk（kernel/vm.c:72）模仿RISC-V分页硬件为虚拟地址查找PTE的过程。walk每次使用9位，向下查找3级页表。他使用虚拟地址中每层的9位查找下层页表所在的PTE或者最终页（kernel/vm.c:78）。如果PTE无效，那需要的页还没有分配；如果alloc参数被设置，walk分配一个新的页表页，并将它的物理地址放在PTE中。walk返回最底层树的PTE的地址（kernel/vm.c:88）。

上面的代码需要物理地址直接映射到内核虚拟地址空间。举例来说，当walk向下层页表查找时，它将下层页表的（物理）地址从当前PTE取出（kernel/vm.c:80），作为一个虚拟地址来寻找再下一层的PTE（kernel/vm.c:78）。

main调用kvminithart（kernel/vm.c:53）来安装内核页表。它先将根页表页的地址存放到satp。之后CPU就能使用内核页表翻译地址。因为内核使用~~恒等映射~~，下一条指令的虚拟地址将正确地映射到物理地址上。

procinit（kernel/proc.c:26）被main调用，为每个进程分配内核栈。它将每个栈映射到KSTACK生成的虚拟地址上。KSTACK生成虚拟地址时会预留不可用的栈保护页。kvmmap将映射的PTE加到内核地址空间，然后kvminithart将内核页表重载到satp，来告诉硬件新PTE的存在。

每个RISC-V CPU都会在TLB中缓存PTE。当xv6切换页表时，必须告诉CPU把TLB中的缓存失效化。否则，在后面一段时间内，TLB仍然持有老的缓存映射，此时这个虚拟地址可能已经分配给里其他进程。这样，进程可能会修改其他进程的内存。RISC-V有一个指令sfence.vma用来清除当前CPU的TLB。xv6在kvminithart函数中，重载satp寄存器后都会执行sfence.vma指令。在跳板代码中返回用户空间之前切换用户页表后也要执行这个指令。

# 3.4 物理内存分配

内核必须在运行时分配和释放物理内存，用于页表，用户内存，内核栈和管道缓存。

xv6使用内核终点与PHYSTOP之间的物理内存来运行时分配。它每次分配和释放的都是一整个4096字节的页。它通过维护一个物理页组成的链表来知道那个页是未分配的。分配包括从链表中删除这个页；释放则要将页加入到链表中。

# 3.5 代码：物理内存分配器

分配器代码位于kalloc.c（kernel/kalloc.c:1）中。分配器的数据结构是一个由可供分配的空闲物理内存页组成的表。每个空闲页的链表元素是一个run结构体（kernel/kalloc.c:17）。分配器从哪获取存放这个数据结构的空间呢？它将每个空闲页的run结构体存放在页本身，因为上面没存放任何其他东西。空闲页链表由一个内旋锁（kernel/kalloc.c:17）保护。链表与锁放在同一个结构体内，来保证锁保护了结构体能的所有域。从现在起，忽略锁和对acquire和release的调用；第6章将详细地讨论锁。

main函数调用kinit来初始化分配器（kernel/kalloc.c:27）。kinit初始化空闲页链表来存放内核末端与PHYSTOP之间的每一个页。xv6本应该通过解析硬件提供的配置信息来确定可用的物理内存大小。xv6假设计算机有128MB RAM。kinit调用freerange来向空闲页链表添加内存，每个页都调用一次kfree函数。PTE只能表示一个以4096字节为界对齐的物理地址（所以地址一定是4096的倍数），所以freerange使用PGROUNDUP来保证它释放的是对齐的物理地址。分配器开始时没有内存，这些对kfree的调用给了它一些可管理的内存。

分配器有时将地址当成整数，用来做算术运算（例如在freerange中遍历所有页时），有时将地址用作指针，来读取和写入内存（例如操作操作每个页中的run结构体时）；这些不同的用法正是分配器代码中充满了C语言类型转换的主要原因。另外一个原因是释放和分配本身就会会改变内存的类型。

kfree函数（kernel/kalloc.c:47）首先将要释放的内存中的每一个字节设置为1。这将使得释放内存后还继续使用内存的代码（使用空悬指针）读到垃圾而不是有效内容；希望能让这些代码更快出问题。kfree将释放的页添加到空闲页链表中：它将pa指针转换为指向结构体run的指针，将旧的空闲页链表的开头记录在r->next，然后将空闲页链表设置为r。kalloc移除空闲页链表中的第一个元素，然后返回它。

traversing inherently  dangling references  prepends

# 3.6 进程地址空间

每个进程都有一个独立的页表，当xv6在进程间切换的时候，也会切换页表。如图2.3，进程的用户内存从虚拟地址0开始，能够增长到MAXVA（kernel/riscv.h:348），这让一个进程理论上能够寻址256GB的内存。

当进程向xv6请求更多的用户内存时，xv6使用kalloc来分配物理页。然后它在进程页表中添加指向新物理页的PTE。xv6在这些PTE中设置PTE_W，PTE_X，PTE_R，PTE_U，PTE_V标志。大部分进程用不到完整的用户地址空间；在未使用的PTE中，xv6不设置PTE_V。

我们在这里看到了一些优雅的使用页表的例子。第一，不同进程的页表将他们的用户地址翻译到不同的物理内存页，所以每个进程都拥有私有的用户内存。第二，每个进程所看到的内存都有着连续的，从0开始的虚拟地址，而进程的物理内存可以是不连续的。第三，进程将一个包含跳板代码的页映射到用户地址空间的顶部，因此这个物理内存页出现在所有的地址空间中。

图3.4更详细地展示了xv6中的一个正在执行的进程的内存布局。栈是一个单独页面，是exec创建进程时的初始化内容之一。栈最顶部是包含命令行参数的字符串，即一个指向他们的指针组成的数组。下面是程序从main开始执行时所需要的值，看起来好像main(argc, argv)刚刚被调用。

为了检测用户栈溢出已分配的栈内存，xv6在栈下面放置了一个保护页。如果用户栈溢出，进程尝试使用栈下面的地址，硬件将产生一个页错误异常，因为映射是无效的。真实世界的操作系统可能在用户栈溢出时自动分配更多的内存。

principle

# 3.7 代码：sbrk

sbrk是进程缩减或增长内存使用的系统调用。系统调用是靠growproc函数（kernel/proc.c:239）实现的。growproc根据n的正负来调用uvmalloc或uvmdealloc。uvmalloc（kernel/vm.c:229）使用kalloc分配物理内存，并使用mappages向用户页表添加PTE。uvmdelloc调用uvmunmap（kernel/vm.c:174），它使用walk来查找PTE，然后用kfree来释放它们指向的物理内存。

xv6的进程页表不仅用来高速硬件如何映射用户虚拟地址，也是分配给进程的物理页的唯一记录。这就是释放用户内存时（在uvmunmap中）需要检查用户页表的原因。

# 3.8 代码：exec

exec是用来创建地址空间中用户部分的系统调用。它用文件系统中的一个文件初始化地址空间中的用户部分。exec（kernel/exec.c:13）使用namei（kernel/exec.c:26）打开命名为二进制的path，这将在第八章中介绍。然后读取ELF头。xv6应用使用广泛使用的ELF格式来描述，ELF格式定义在（kernel/elf.h）中。一个ELF二进制文件由ELF头，即elfhdr结构体（kernel/elf.h:6），以及紧随其后的一系列程序段头构成，程序段头由proghdr结构体（kernel/elf.h:25）表示。每个proghdr描述了应用中必须被加载到内存中的一段；xv6程序只有一个程序段头，但其他操作系统中可能指令和数据分别有自己的段。

第一步是快速检查文件是否包含ELF二进制。ELF二进制文件以四字节的“魔术数字”开头：0x7E,'E','L','F'，又叫ELF_MAGIC（kernel/elf.h:3）。如果ELF头有正确的魔术数字，exec就假设这个二进制是符合格式的。

exec使用proc_pagetable（kernel/elf.h:3）来分配一个新页表，其中没有任何的用户映射，使用uvmalloc（kernel/exec.c:52）为每个ELF段分配内存，然后使用loadseg（kernel/exec.c:10）将程序段加载到内存中。loadseg使用workaddr来找到为写ELF段的每一页而分配的内存，然后使用readi来从文件中读取。

/init，使用exec创建的第一个用户程序，程序段头是这样：

** TBD **

程序段头部的filesz可能小于memsz，说明它们之间的空隙应该被0填满（对C全局变量来说）而不是从文件中读取。对/init来说，filesz为2112字节，memsz为2136字节，因此uvmalloc分配了足够的物理内存来存放2136字节，但只从/init文件中读取2112字节。

现在exec分配内存并初始化了用户栈。它只分配了一个栈页。exec每次一个，向栈顶复制参数字符串，将它们的指针记录在ustack中。它将一个空指针放在即将成为传递给main函数的argv表的尾部。ustack中的前三个项分别是伪返回程序指针，argc和argv指针。

exec在栈页的下方放置了一个不可访问页，所以想要使用一页以上的程序会报错。这个不可访问的页也使得exec能够处理太大的参数；在这种情况下，exec使用的用来向栈中拷贝参数的copyout函数（kernel/vm.c:355）会发现目标页无法访问，然后返回-1。

在准备新的内存镜像时，如果exec检测到一个错误，例如无效程序段，它将跳转到bad标签，释放新镜像，然后返回-1。exec必须确认系统调用成功后才能释放旧镜像：如果没有旧镜像，系统调用无法向它返回-1。exec中惟一的出错可能发生在镜像的创建中。一旦镜像创建完成，exec可以提交到新页表（kernel/exec.c:113）中，然后释放旧页表（kernel/exec.c:117）。

exec将ELF文件中的内容加载到内存中ELF文件中指定的地址处。用户或进程可以将他们想要的任何地址放在ELF文件中。因此exec是有风险的，因为ELF文件中的地址可能无意或有意地指向内核。如果内核对此毫无防备，可能引发严重后果，轻则系统崩溃，重则内核隔离机制被完全破坏（即一个安全漏洞）。为防范这些风险，xv6进行了一系列检查。例如，if(ph.vaddr + ph.memsz < ph.vaddr)检查总和是否溢出了64位整数。危险在于，用户可能使用一个指向用户所选择地址的ph.vaddr，而ph.memsz足够大，它们俩的和溢出64位整数，变为0x1000，看起来是可用的值。在xv6的一个老版本中，用户地址空间也包含内核（但在用户模式下不可读写），用户可以选择一个指向内核内存的地址，并因此从ELF二进制文件中拷贝数据到内核。在xv6的RISC-V版本中这不可能发生，因为内核有它自己单独的页表；loadseg加载到用户页表而不是内核页表。

内核开发者很容易忽略严格的检查，真实世界中的内核有很长的历史，有些检查的缺失导致用户程序能够利用这个漏洞获取内核特权。xv6可能没有在用户层给内核的数据做完整的有效性检查，恶意用户程序可能利用这个漏洞，欺骗xv6的隔离机制。

unwary exploit subversion supply circumvent 

# 3.9 真实世界

跟很多操作系统一样，xv6使用分页硬件来保护和映射内存。大部分操作系统使用了远比xv6复杂的分页，将分页和页错误异常结合起来，我们将在第四章讨论页错误异常。

xv6基于下面的原因得到简化：内核使用虚拟地址到物理地址的直接映射；假设物理RAM在地址0x8000000处存在，内核期望在这里加载。这在QEMU上是有效的，但在真实硬件上行不通。真实硬件将RAM和硬件设备放置在无法预测的物理地址上，所以（举个例子）有可能在 xv6期望加载内核的0x8000000处没有RAM。更多的内核设计利用页表将随机的硬件物理内存布局转化为可预测的内核虚拟地址布局。

RISC-V提供了物理地址级别的保护，但xv6没有使用这个功能。

在有大量内存的机器上，使用RISC-V提供的“超级页”功能可能会很有用。当物理内存小的时候，小的页在允许使用精细粒度分配内存和换出到磁盘的操作时非常有用。比方说，如果一个程序只是用8KB内存，给它一整个4MB的超级页的物理内存就很浪费。越大的页在拥有大量RAM的机器上越有用，能够减少页表操作上的开销。

xv6内核缺少类似malloc的分配器来给小尺寸的对象提供内存。这阻止了内核使用需要动态分配的复杂数据结构。

内存分配是一个经久不衰的主题，基本问题是高效使用有限内存和为未知的未来需求做准备。今天，人们更多地考虑速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是(像在xv6中)只有4096字节的块；一个真正的内核分配器既需要处理小内存分配也要处理大内存分配。

granularity  overhead  perennial  
