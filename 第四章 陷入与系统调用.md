有三种类型的事件会让CPU停止正常执行的指令，强制切换到指定的代码，处理这些事件。一种是系统调用，当用户程序执行ecall指令来让内核为它做一些事。另一种是异常：一个指令（用户或内核）做了一些非法的事，比方说除以0或者使用无效的虚拟地址。第三种是设备中断，当设备发信号说它需要关注时，比方说当磁盘硬件完成了读或写的请求。

本书使用trap作为这些情况的通用术语。通常，不管trap发生时在执行什么代码，后面都需要恢复，这些代码不需要知道发生了什么不同的事。就是说，我们通常需要trap是透明的：这对中断来说尤其重要，被打断的代码不希望中断发生。通常的执行顺序是，trap强制将控制转移到内核；内核保存寄存器和其他的状态，以便之后执行能恢复；内核执行合适的处理代码（例如系统调用实现或设备驱动）；内核重载保存的状态，从trap中返回；最初的代码从它离开的位置恢复。

xv6内核处理所有的trap。这对系统调用来说自然而然。对中断也有意义，因为隔离要求用户进程不直接使用设备，而且内核拥有设备处理所需要的状态。对异常同样有意义，因为xv6对所有来自用户空间的异常都是同样的回应：干掉产生异常的程序。

xv6的trap处理分四步进行：1. RISC-V CPU采取的硬件动作，2. 一个汇编写的向量表通向内核的C代码，3. C语言trap handler决定怎么处理这个trap，4. 系统调用或设备驱动服务例行程序。虽然三种trap类型的共同点说明内核能够通过一条代码路径处理所有的trap，事实证明，对三种不同的实例分别使用不同的汇编向量表更方便：用户空间trap，内核空间trap，计时器中断。

distinct

# 4.1 RISC-V 陷入机制

每个RISC-V CPU都有一组控制寄存器，内核通过写入这些寄存器告诉CPU怎样处理trap，内核也可以读取这些寄存器来知道trap的发生。RISC-V文件详述了整个过程。riscv.h（kernel/riscv.h:1）包含xv6使用的定义。下面是大部分主要寄存器的说明：

- stvec：内核将trap handler的地址写在这；RISC-V跳到这里来处理一个trap。
- sepc：当trap发生时，RISC-V将程序计数器保存在这（因为pc会被stvec覆盖掉）。sret（从trap返回）指令将sepc拷贝到pc。内核可以通过写入sepc来控制sret返回到哪里。
- scause：RISC-V将引发trap的原因编号放在这。
- sscratch：内核把一个值放在这，它将在trap handler最开始派上用场。
- sstatus：sstatus中的SIE位控制了设配中断是否被允许。如果内核清空了SIE，RISC-V将推迟设备中断，直到内核设置SIE位。SPP位表示trap是来自用户模式还是管理者模式，也控制了sret返回到什么模式。

上面的寄存器与管理者模式下处理的trap有关，它们不能在用户模式下被读写。在机器模式下也有一组等价的寄存器，xv6只在特殊的定时器中断下使用它们。

多核芯片上的每个CPU都有它自己的一组寄存器，在任意给定的时间可能不止一个CPU在处理一个trap。

当需要强制陷入时，RISC-V硬件对所有trap类型（除了定时器中断）执行下列步骤：

1. 如果trap是设备中断，且sstatus中的SIE位被清除，则不再向下执行
2. 通过清除SIE禁止中断
3. 将pc拷贝到sepc中
4. 在sstatus中的SPP位保存当前模式（用户或管理者）
5. 设置scause来反映trap的触发原因
6. 将模式设置为管理者
7. 将stvec拷贝到pc
8. 在新的pc处开始执行

请注意，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除pc外的任何寄存器。内核软件必须完成这些工作。CPU在trap过程中只做最少工作的一个原因，是为软件提供灵活性；比方说，有些操作系统不在某些情况下不需要页表切换，这能够提高性能。

你可能会好奇，是否还能进一步简化CPU硬件的trap处理过程。比方说，假设CPU不切换程序计数器。然后，trap可能切换到管理者模式，却仍然运行用户指令。这些用户指令将破坏用户、内核之间的隔离，举例来说，通过修改satp寄存器来指向一个允许访问所有物理内存的页表。因此，CPU切换到内核指定的指令地址即stvec非常重要。

comes in handy  defer 

# 4.2 来自用户空间的trap

trap可能发生在用户空间，当用户程序发起系统调用（ecall指令），或做了非法的事情，或者设备中断。来自用户空间的trap的~~高层路径~~是：uservec（kernel/trampoline.S:16），然后usertrap（kernel/trap.c:37）；返回时，usertrapret（kernel/trap.c:90），然后userret（kernel/trampoline.S:16）。

来自用户代码的的traps比来自内核的更复杂，因为satp指向用户页表，而不映射内核，而且栈指针可能包含一个无效甚至恶意的值。

因为RISC-V硬件在trap中不切换页表，用户页表必须包含一个指向uservec的映射，uservec是stvec指向的trap向量表的所有指令。uservec切换satp使其指向内核页表；为了在切换之后继续执行指令，uservec在内核页表与用户页表中必须位于同一个地址。

xv6使用一个包含uservec的跳板页来满足这些限制条件。xv6在内核页表中与每个用户页表中都将跳板页应设在一个相同的虚拟地址上。这个虚拟地址就是TRAMPOLINE（正如我们在图2.3与图3.3中看到的）。跳板内容在trampoline.S中设置，而且，（当执行用户代码时）stvec被设置为uservec（kernel/trampoline.S:16）。

当uservec开始执行时，所有32个寄存器中包含的都是被打断的代码所拥有的值。但是uservec需要修改一些寄存器来设置satp，并生成存放寄存器的地址。RISC-V以sscratch寄存器的形式提供了帮助。uservec中最开始的指令csrrw减缓了a0与sscratch寄存器的内容。现在用户代码中的a0得到了保存，uservec也有了一个寄存器a0可以使用，而且a0包含了内核之前放在sscratch寄存器中的值。

uservec接下来的任务是保存用户寄存器。在进入用户空间之前，内核设置sscratch，指向一个每个进程的trapframe，这个帧有空间保存所有的用户寄存器（kernel/proc.h:44）。因为satp任然指向用户页表，uservec需要这个trapframe在用户页表中可以映射。当创建每个进程是，xv6为这个进程的trapframe分配一个页，然后把它跟用户虚拟地址TRAPFRAME建立映射关系，这个虚拟地址紧邻TRAMPOLINE，在其下面。进程的p->trapframe也指向trapframe，它指向trapframe的物理地址，这样内核就能通过内核页表使用trapframe。

因此，在交换a0和sscratch后，a0保存了一个指向当前进程trapframe的指针。uservec现在将所有的用户寄存器保存在那里，包括从sscratch中读到的用户的a0。

trapframe包含了指向当前进程内核栈的指针，当前CPU的hartid，usertrap的地址，以及内核页表的地址。uservec检索这些信息，将satp切换到内核页表，然后调用usertrap。

usertrap的工作是确定trap的触发原因，执行它，然后返回（kernel/trap.c:37）。正如上面所提到的，它首先修改stvec使得trap将被kernelvec处理。它再次保存sepc（被保存永和程序计数器），因为在usertrap中可能有进程切换，这会导致sepc被覆盖。如果trap是一个系统调用，syscall处理它；如果是用户中断，devintr；如果是异常，内核直接杀掉出错的进程。系统调用路线会在保存的用户pc上加4，因为RISC-V在系统调用时，将程序指针留在了ecall指令处。在离开时，usertrap会检查是否进程已经被杀掉，或者是否应该CPU让权（如果trap是计时器中断）。

返回用户空间的第一步是调用usertrapret（kernel/trap.c:90）。这个函数设置好RISC-V的控制寄存器，准备好迎接下一个来自用户空间的trap。这包括修改stvec让它指向uservec，准备uservec依赖的trapframe域，以及设置sepc为之前保存的用户程序计数器。最后，usertrapret调用用户或内核页表跳板页上的userret；这么说的原因是userret中的汇编代码会切换页表。

usertrapret对userret的调用在a0中传递了指向进程用户页表的指针，在a1中传递了指向TRAPFRAME的指针（kernel/trampoline.S:88）。userret将satp切换到进程的用户页表。回忆一下，用户页表除了trampoline页和TRAPFRAME外，没有映射内核的任何东西。再一次，trampoline页在用户页表和内核页表被映射到同一虚拟地址的事实，使得uservec能够在修改satp后继续执行。userret将trapframe所保存的用户a0复制到sscratch来为后面与TAPFRAME的交换做准备。从此开始，userret能使用的数据只有寄存器内容和trapframe中的内容。下一个userret从trapframe中恢复保存的用户寄存器，最后交换一次a0和sscratch来恢复用户a0，为下一个trap保存TRAPFRAME，然后调用sret返回用户空间。

retrieve

# 4.3 代码：使用系统调用

第二章截止于initcode.S调用exec系统调用（user/initcode.S:11）。我们来看一下，用户的调用是怎样调到内核中exec系统调用的实现的。

用户代码将exec的参数放在a0和a1中，将系统调用号放在a7中。系统调用号与systemcalls数组中的项匹配，systemcalls是一个函数指针表（kernel/syscall.c:108）。ecall指令陷入内核，然后执行uservec，usertrap，然后是syscall，正如我们上面所看到的。

syscall（kernel/syscall.c:133）从trapframe所保存的a7中找到系统调用号，用它索引对应的系统调用。对第一个系统调用来说，a7包含了SYS_exec（kernel/syscall.h:8），转到对系统调用实现函数sys_exec的调用。

当系统调用实现函数返回时，syscall将它的返回值记录在p->trapframe->a0中。这将使得最初用户空间调用的exec()函数返回这个值，因为RISC-V中C语言函数调用的惯例是将返回值放在a0寄存器中。系统调用返回值的惯例是用负值表示错误，0或正数表示成功。如果系统调用号是无效的，syscall打印错误并返回-1。

convention

# 4.4 代码：系统调用参数

# 4.5 来自内核空间的trap

# 4.6 页错误异常

# 4.7 真实世界
