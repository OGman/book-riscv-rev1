有三种类型的事件会让CPU停止正常执行的指令，强制切换到指定的代码，处理这些事件。一种是系统调用，当用户程序执行ecall指令来让内核为它做一些事。另一种是异常：一个指令（用户或内核）做了一些非法的事，比方说除以0或者使用无效的虚拟地址。第三种是设备中断，当设备发信号说它需要关注时，比方说当磁盘硬件完成了读或写的请求。

本书使用trap作为这些情况的通用术语。通常，不管trap发生时在执行什么代码，后面都需要恢复，这些代码不需要知道发生了什么不同的事。就是说，我们通常需要trap是透明的：这对中断来说尤其重要，被打断的代码不希望中断发生。通常的执行顺序是，trap强制将控制转移到内核；内核保存寄存器和其他的状态，以便之后执行能恢复；内核执行合适的处理代码（例如系统调用实现或设备驱动）；内核重载保存的状态，从trap中返回；最初的代码从它离开的位置恢复。

xv6内核处理所有的trap。这对系统调用来是自然而然。对中断也有意义，因为隔离要求用户进程不直接使用设备，而且内核拥有设备处理所需要的状态。对异常同样有意义，因为xv6对所有来自用户空间的异常都是同样的回应：干掉产生异常的程序。

xv6的trap处理分四步进行：RISC-V CPU采取的硬件动作，一个汇编写的向量表通向内核的C代码，C语言trap handler决定怎么处理这个trap，以及系统调用或设备驱动服务例行程序。虽然三种trap类型的共同点说明内核能够通过一条代码路径处理所有的trap，事实证明，对三种不同的实例分别使用不同的汇编向量表更方便：用户空间trap，内核空间trap，计时器中断。

distinct
