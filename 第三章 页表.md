操作系统通过页表为每一个进程提供了它自己的私有地址空间和内存。页表决定了内存地址表示什么，也决定了哪部分物理地址可以被访问。它们允许xv6将不同进程的地址空间隔离开来，并将他们复用到同一物理内存上。页表提供了一个间接层，让xv6能玩一些小花招：将同一段内存（跳板页）映射到不同的地址空间，使用未映射的页来保护内核和用户栈。本章中其他部分解释了RISC-V硬件所提供的页表，以及xv6如何使用它们。

# 3.1 分页硬件

提醒一下，RISC-V指令（包括用户和内核）使用虚拟地址。而机器的RAM，或物理内存，使用物理地址进行索引。RISC-V页表硬件连接这两种地址，将虚拟地址映射到物理地址。

xv6运行在Sv39 RISC-V上，这表示在64位虚拟地址中，只使用了低39位，而高25位未使用。在这种Sv39配置中，RISC-V页表逻辑上是一个包含2^27（134,217,728）个页表项（PTE，page table entry）的向量表。每个PTE包含一个44位物理页编码（PPN，physical page number）和一些标志位。分页硬件使用39位虚拟地址中的高27位作为索引，在页表中找到对应的PTE，然后用PTE中的44位地址作为高位，虚拟地址中的低12位作为地位，构造出一个56位的物理地址。图3.1展现了这个过程，其中页表按照逻辑理解，被描绘为一个PTE构成的向量表（图3.2给出了真实情况）。页表给予了操作系统控制虚拟地址到物理地址翻译的能力。内存的粒度大小是4096（2^12）的对齐块。这种块叫作页。

在Sv39 RISC-V中，高25位没有参与到地址转换中；未来RISC-V可能会使用这些位定义更多层的地址转换。物理地址也还有增加的空间：PTE格式中的物理页编号仍有增长10位的空间。

如图3.2，实际的地址转换分为三步。页表以三层树的结构保存在物理内存中。树的根是一张4096字节的页表，包含512PTE，每个PTE都包含了下一层页表存放页的物理地址。这些页中包含了512PTE，保存树的最终层。分页硬件使用27位中的高9位查找根页表中的PTE，中9位查找中层页表中的PTE，低9位查找最终PTE。

翻译地址时，如果所需要的三个PTE中有任意一个不存在，分页硬件都会产生一个分页错误异常，让内核去处理这个异常（参见第四章）。这个三层结构让页表无需存放完整的页表，因为大段的虚拟地址没有映射是非常常见的情况。

每个PTE都包含标志位，用来告诉分页硬件，关联的页允许怎样使用。PTE_V表示PTE是否存在：如果没设置它，对这个页的引用会产生异常（即不允许）。PTE_R控制是否允许指令读这个页。PTE_W控制是否允许指令写这个页。PTE_X决定CPU是否能将页中国的内容解释为指令并运行它们。PTE_U控制是否允许用户模式下的指令访问这个页；如果未设置PTE_U，PTE只能在管理者模式下使用。图3.2描绘了它的工作方法。这些标志位和所有其他与分页硬件相关的结构体都定义在（kernel/riscv.h）中。

为了让硬件使用页表，内核必须将根页表页的物理地址写入satp寄存器中。每个CPU都有它自己的satp。CPU会将后续所有指令产生的地址都使用它satp中所存放的页表进行翻译。每个CPU拥有自己的satp寄存器，所以不同的CPU可以运行不同的进程，每个进程都有用它自己的页表描述的私有的地址空间。

一些名词需要解释一下。物理内存指的是DRAM中的存储单元。每一字节的物理内存都有一个地址，叫物理地址。指令只使用虚拟地址，分页硬件将虚拟地址翻译成物理地址，然后发送给DRAM硬件来读取或写入存储。虚拟内存不像物理内存和虚拟地址那样，它不是物理实体。它指的是内核提供的用来管理物理内存和虚拟地址的抽象和机制的集合。

# 3.2 内核地址空间

xv6为每个进程维护一张页表，用来描述进程的用户地址空间。为内核也维护了一张页表，用于描述内核地址空间。内核注册了这个地址空间的布局，来为自己提供在已知虚拟地址上访问物理内存和各种硬件资源的便利。图3.3展现了这个布局如何将内核虚拟地址映射到物理地址上。文件 (kernel/memlayout.h)声明了xv6内核内存布局的各种常量。

QEMU模拟了一台计算机，它的RAM（物理内存）从物理地址0x80000000开始，一直到至少0x86400000才结束，结束点在xv6中称为PHYSTOP。QEMUdemonic也包括硬盘接口之类的I/O设备。QEMU将设备接口以映射在内存的控制寄存器的形式暴露给软件，它们的位于0x80000000之前的物理地址空间。内核能够通过读/写这些特殊物理地址的方式与设备交互；这些读写操作直接与设备硬件通信，而不是RAM。第四章解释了xv6怎样与设备交互。

内核使用“直接映射”来获取RAM与应设在内存上的设备寄存器。直接映射就是说，将资源映射在与物理地址相同的虚拟地址上。举例来说，内核本身在虚拟地址和物理地址上都位于KERNBASE=0x80000000。直接映射简化了读写物理内存的内核代码。例如，当fork为子进程分配用户内存时，分配器返回内存的物理地址；当fork将父进程的用户内存拷贝给子进程时，直接使用这个地址作为虚拟地址。

有一些内核虚拟地址没有被直接映射：

- 跳板页。跳板页被映射在虚拟地址空间的顶部；用户页表也有同样的映射。第4章讨论了跳板页扮演的角色，但我们这里只把它看成是一种有趣的页表使用实例；物理页（包含跳板代码）在内核虚拟地址空间中被映射了两次：一次在虚拟地址空间的顶部，一次是直接映射。

- 内核栈页。每个进程都有自己的内核栈，映射在高地址，以便xv6能在它下面放置一个未映射的保护页。保护页的PTE是无效的（比方说PTE_V未设置），因此当内核栈溢出时，有可能引起异常，内核将报错。没有保护页的话，溢出的栈将覆盖别的内核内存，造成运行错误。内核报错是更好的结果。

当内核通过高位内存映射使用内核栈时，这些栈也可以被内核通过直接映射的地址使用。另一种设计可能是只使用直接映射，在直接映射的地址使用栈。然而，在这种设计中，提供保护页必须包括取消它的虚拟地址映射，否则将映射到物理内存，这使用起来将会很麻烦。

内核给映射跳板页和内核代码的页PTE_R与PTE_X权限，因为内核需要读取并运行这些页上的指令。对映射的其他页赋予PTE_R与PTE_W权限，从而能够读写这些页上的内存。保护页的映射是无效的。

# 3.3 代码：创建地址空间

xv6中，大部分操作地址空间和页表的代码都位于vm.c（kernel/vm.c:1）中。其中核心的数据结构是pagetable_t，是一个指向RISC-V根页表页的指针；一个pagetable_t可能是内核页表，也可能是一个进程页表。核心函数有：walk，按照虚拟地址找到PTE；mappages，为新的映射安装PTE。以kvm开头的函数用来操作内核页表；以uvm开头的函数操作用户页表；其他的函数两者都可以用。copyout函数向用户虚拟地址拷贝数据，copyin则从用户虚拟地址拷贝数据到内核，并作为系统调用的参数；因为它们需要显式地翻译这些地址为对应的物理地址，所以它们也放在vm.c中。

在boot流程的早期，main调用kvminit（kernel/vm.c:22）来创建内核页表。这个调用发生时，xv6还不能在RISC-V上分页，所以地址直接指向物理内存。Kvminit首先分配一页物理内存来存放根页表页。然后ta调用kvmmap来安装内核需要的翻译。翻译包括内核的指令和数据，到PHYSTOP的物理地址，以及实际是设备的内存段。

kvmmap（kernel/vm.c:118）调用mappages（kernel/vm.c:149）向一个页表安装从一段虚拟地址向对应的物理地址的映射。它以页大小为间隔，为地址段中每个虚拟地址分别执行此操作。对每个需要映射的虚拟地址，mappages调用walk来找到对应该地址的PTE位置。然后它初始化这个PTE来存放对应的物理页编号，需要的权限（PTE_W，PTE_X，PTE_R），用PTE_V标记PTE是否可用（kernel/vm:161）。

walk（kernel/vm.c:72）模仿RISC-V分页硬件为虚拟地址查找PTE的过程。walk每次使用9位，向下查找3级页表。他使用虚拟地址中每层的9位查找下层页表所在的PTE或者最终页（kernel/vm.c:78）。如果PTE无效，那需要的页还没有分配；如果alloc参数被设置，walk分配一个新的页表页，并将它的物理地址放在PTE中。walk返回最底层树的PTE的地址（kernel/vm.c:88）。

上面的代码需要物理地址直接映射到内核虚拟地址空间。举例来说，当walk向下层页表查找时，它将下层页表的（物理）地址从当前PTE取出（kernel/vm.c:80），作为一个虚拟地址来寻找再下一层的PTE（kernel/vm.c:78）。

main调用kvminithart（kernel/vm.c:53）来安装内核页表。它先将根页表页的地址存放到satp。之后CPU就能使用内核页表翻译地址。因为内核使用~~恒等映射~~，下一条指令的虚拟地址将正确地映射到物理地址上。

procinit（kernel/proc.c:26）被main调用，为每个进程分配内核栈。它将每个栈映射到KSTACK生成的虚拟地址上。KSTACK生成虚拟地址时会预留不可用的栈保护页。kvmmap将映射的PTE加到内核地址空间，然后kvminithart将内核页表重载到satp，来告诉硬件新PTE的存在。

每个RISC-V CPU都会在TLB中缓存PTE。当xv6切换页表时，必须告诉CPU把TLB中的缓存失效化。否则，在后面一段时间内，TLB仍然持有老的缓存映射，此时这个虚拟地址可能已经分配给里其他进程。这样，进程可能会修改其他进程的内存。RISC-V有一个指令sfence.vma用来清除当前CPU的TLB。xv6在kvminithart函数中，重载satp寄存器后都会执行sfence.vma指令。在跳板代码中返回用户空间之前切换用户页表后也要执行这个指令。

# 3.4 物理内存分配

内核必须在运行时分配和释放物理内存，用于页表，用户内存，内核栈和管道缓存。

xv6使用内核终点与PHYSTOP之间的物理内存来运行时分配。它每次分配和释放的都是一整个4096字节的页。它通过维护一个物理页组成的链表来知道那个页是未分配的。分配包括从链表中删除这个页；释放则要将页加入到链表中。

# 3.5 代码：物理内存分配器

分配器代码位于kalloc.c（kernel/kalloc.c:1）中。分配器的数据结构是一个由可供分配的空闲物理内存页组成的表。每个空闲页的链表元素是一个run结构体（kernel/kalloc.c:17）。分配器从哪获取存放这个数据结构的空间呢？它将每个空闲页的run结构体存放在页本身，因为上面没存放任何其他东西。空闲页链表由一个内旋锁（kernel/kalloc.c:17）保护。链表与锁放在同一个结构体内，来保证锁保护了结构体能的所有域。从现在起，忽略锁和对acquire和release的调用；第6章将详细地讨论锁。

main函数调用kinit来初始化分配器（kernel/kalloc.c:27）。kinit初始化空闲页链表来存放内核末端与PHYSTOP之间的每一个页。xv6本应该通过解析硬件提供的配置信息来确定可用的物理内存大小。xv6假设计算机有128MB RAM。kinit调用freerange来向空闲页链表添加内存，每个页都调用一次kfree函数。


# 3.6 进程地址空间

# 3.7 代码：sbrk

# 3.8 代码：exec

# 3.9 真实世界
