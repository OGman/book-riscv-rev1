操作系统通过页表为每一个进程提供了它自己的私有地址空间和内存。页表决定了内存地址表示什么，也决定了哪部分物理地址可以被访问。它们允许xv6将不同进程的地址空间隔离开来，并将他们复用到同一物理内存上。页表提供了一个间接层，让xv6能玩一些小花招：将同一段内存（跳板页）映射到不同的地址空间，使用未映射的页来保护内核和用户栈。本章中其他部分解释了RISC-V硬件所提供的页表，以及xv6如何使用它们。

# 3.1 分页硬件

提醒一下，RISC-V指令（包括用户和内核）使用虚拟地址。而机器的RAM，或物理内存，使用物理地址进行索引。RISC-V页表硬件连接这两种地址，将虚拟地址映射到物理地址。

xv6运行在Sv39 RISC-V上，这表示在64位虚拟地址中，只使用了低39位，而高25位未使用。在这种Sv39配置中，RISC-V页表逻辑上是一个包含2^27（134,217,728）个页表项（PTE，page table entry）的向量表。每个PTE包含一个44位物理页编码（PPN，physical page number）和一些标志位。分页硬件使用39位虚拟地址中的高27位作为索引，在页表中找到对应的PTE，然后用PTE中的44位地址作为高位，虚拟地址中的低12位作为地位，构造出一个56位的物理地址。图3.1展现了这个过程，其中页表按照逻辑理解，被描绘为一个PTE构成的向量表（图3.2给出了真实情况）。页表给予了操作系统控制虚拟地址到物理地址翻译的能力。内存的粒度大小是4096（2^12）的对齐块。这种块叫作页。

在Sv39 RISC-V中，高25位没有参与到地址转换中；未来RISC-V可能会使用这些位定义更多层的地址转换。物理地址也还有增加的空间：PTE格式中的物理页编号仍有增长10位的空间。

如图3.2，实际的地址转换分为三步。页表以三层树的结构保存在物理内存中。树的根是一张4096字节的页表，包含512PTE，每个PTE都包含了下一层页表存放页的物理地址。这些页中包含了512PTE，保存树的最终层。分页硬件使用27位中的高9位查找根页表中的PTE，中9位查找中层页表中的PTE，低9位查找最终PTE。

翻译地址时，如果所需要的三个PTE中有任意一个不存在，分页硬件都会产生一个分页错误异常，让内核去处理这个异常（参见第四章）。这个三层结构让页表无需存放完整的页表，因为大段的虚拟地址没有映射是非常常见的情况。

每个PTE都包含标志位，用来告诉分页硬件，关联的页允许怎样使用。PTE_V表示PTE是否存在：如果没设置它，对这个页的引用会产生异常（即不允许）。PTE_R控制是否允许指令读这个页。PTE_W控制是否允许指令写这个页。PTE_X决定CPU是否能将页中国的内容解释为指令并运行它们。PTE_U控制是否允许用户模式下的指令访问这个页；如果未设置PTE_U，PTE只能在管理者模式下使用。图3.2描绘了它的工作方法。这些标志位和所有其他与分页硬件相关的结构体都定义在（kernel/riscv.h）中。

为了让硬件使用页表，内核必须将根页表页的物理地址写入satp寄存器中。每个CPU都有它自己的satp。CPU会将后续所有指令产生的地址都使用它satp中所存放的页表进行翻译。每个CPU拥有自己的satp寄存器，所以不同的CPU可以运行不同的进程，每个进程都有用它自己的页表描述的私有的地址空间。

一些名词需要解释一下。物理内存指的是DRAM中的存储单元。每一字节的物理内存都有一个地址，叫物理地址。指令只使用虚拟地址，分页硬件将虚拟地址翻译成物理地址，然后发送给DRAM硬件来读取或写入存储。虚拟内存不像物理内存和虚拟地址那样，它不是物理实体。它指的是内核提供的用来管理物理内存和虚拟地址的抽象和机制的集合。

# 3.2 内核地址空间

xv6为每个进程维护一张页表，用来描述进程的用户地址空间。为内核也维护了一张页表，用于描述内核地址空间。内核注册了这个地址空间的布局，来为自己提供在已知虚拟地址上访问物理内存和各种硬件资源的便利。图3.3展现了这个布局如何将内核虚拟地址映射到物理地址上。文件 (kernel/memlayout.h)声明了xv6内核内存布局的各种常量。

QEMU模拟了一台计算机，它的RAM（物理内存）从物理地址0x80000000开始，一直到至少0x86400000才结束，结束点在xv6中称为PHYSTOP。QEMUdemonic也包括硬盘接口之类的I/O设备。QEMU将设备接口以映射在内存的控制寄存器的形式暴露给软件，它们的位于0x80000000之前的物理地址空间。内核能够通过读/写这些特殊物理地址的方式与设备交互；这些读写操作直接与设备硬件通信，而不是RAM。第四章解释了xv6怎样与设备交互。

内核使用“直接映射”来获取RAM与应设在内存上的设备寄存器。直接映射就是说，将资源映射在与物理地址相同的虚拟地址上。举例来说，内核本身在虚拟地址和物理地址上都位于KERNBASE=0x80000000。直接映射简化了读写物理内存的内核代码。例如，当fork为子进程分配用户内存时，分配器返回内存的物理地址；当fork将父进程的用户内存拷贝给子进程时，直接使用这个地址作为虚拟地址。

有一些内核虚拟地址没有被直接映射：

- 跳板页。跳板页被映射在虚拟地址空间的顶部；用户页表也有同样的映射。第4章讨论了跳板页扮演的角色，但我们这里只把它看成是一种有趣的页表使用实例；物理页（包含跳板代码）在内核虚拟地址空间中被映射了两次：一次在虚拟地址空间的顶部，一次是直接映射。

- 内核栈页。每个进程都有自己的内核栈，映射在高地址，以便xv6能在它下面放置一个未映射的保护页。保护页的PTE是无效的（比方说PTE_V未设置），因此当内核栈溢出时，有可能引起异常，内核将报错。没有保护页的话，溢出的栈将覆盖别的内核内存，造成运行错误。内核报错是更好的结果。

当内核通过高位内存映射使用内核栈时，这些栈也可以被内核通过直接映射的地址使用。另一种设计可能是只使用直接映射，在直接映射的地址使用栈。然而，在这种设计中，提供保护页必须包括取消它的虚拟地址映射，否则将映射到物理内存，这使用起来将会很麻烦。

内核给映射跳板页和内核代码的页PTE_R与PTE_X权限，因为内核需要读取并运行这些页上的指令。对映射的其他页赋予PTE_R与PTE_W权限，从而能够读写这些页上的内存。保护页的映射是无效的。

# 3.3 代码：创建地址空间

# 3.4 物理内存分配

# 3.5 代码：物理内存分配器

# 3.6 进程地址空间

# 3.7 代码：sbrk

# 3.8 代码：exec

# 3.9 真实世界
