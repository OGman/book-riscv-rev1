好的并行性能，不考虑并发的正确性，易懂的代码，在内核设计中三者兼得非常困难。直接使用锁是获得正确的最好方式，但并不总能成功。这一章重点介绍了xv6被迫以复杂方式使用锁的例子，以及xv6使用类锁但不是锁的技术。

# 9.1 锁模式

缓存项对锁来说往往是个挑战。举例来说，文件系统的块缓存（kernel/bio.c:26）保存了多达NBUFF的硬盘块的拷贝。每个给定的硬盘块在缓存中最多只有一个拷贝，这很重要；然而，不同的进程可能会在应该是同一个块的不同拷贝上制造相互冲突的修改。每个缓存的块都被保存在一个buff（kernel/buf.h:1）结构体中。buf结构体有一个锁域，用以保证同时只有一个进程使用给定硬盘块。然而，这个锁并不够：如果一个块还不在缓存中，而有两个进程同时想要使用它会怎么样？没有buf结构体（因为块还没有被缓存），因此没有什么东西可以加锁。xv6通过将一个附加锁（bcache.lock）与缓存快的身份集合联系起来，来处理这种情况。代码需要检查块是否已经被缓存（如bget（kernel/bio.c:59）），或修改缓存块集合，这必须持有bcache.lock；在那之后，代码找到了它需要的块和buf结构体，它可以释放bcache.lock，仅仅使用结构体中的锁。这是一种常见的模式：项的整个集合有一个锁，每个项又有自己的锁。

通常，获取锁的函数会释放锁。但观察事物更精确的方式，是锁在一系列需要被合并为原子操作的动作之前被获取，在所有动作完成之后被释放。如果这个序列在不同的函数，进程或者CPU中开始和结束，那锁的获取和释放也应该同步。锁的功能是强制其他的使用者等待，而不是将一段数据固定交给特定的代理。一个例子是yield中的acquire（kernel/proc.c:515），它在调度器线程中被释放而不是获取它的进程中。另一个例子是ilock中的acquiresleep（kernel/fs.c:289）；这些代码通常在读硬盘时睡眠；可能会被另一个CPU唤醒，也就意味着锁可能被别的CPU获取和释放。

