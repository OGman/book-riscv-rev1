操作系统的一个核心需求，是同时执行不同的活动。举个例子，我们可以使用第一章中提到的fork系统调用创建一个新进程。操作系统必须在不同的进程之间对计算机的资源进行时间共享。举例来说，即使有比物理CPU更多的进程在运行，操作系统也必须保证每个进程都有执行的机会。操作系统也必须在不同进程之间实施隔离。就是说，如果一个进程有bug或出现故障，它不应该影响到不依赖它的进程。然而，完全的隔离太强了，应该允许进程之间进行有意识的交互；管道是一个例子。总而言之，操作系统必须满足三大需求： 多任务，隔离以及交互。

本章概述了操作系统如何组织来满足这三个需求。事实证明，有很多方法可以做到这一点，但本文侧重于以单体内核为中心的主流设计，许多 Unix 操作系统都使用这种内核。 本章还概述了xv6进程，它是xv6中的隔离单元。此外还介绍了xv6启动时第一个进程的创建。

xv6运行于多核RISC-V微处理器，它的许多底层功能（比方说进程的实现）只适用于RISC-V。RISC-V是一种64位的CPU，xv6由“LP64”C写成。所谓“LP64”就是说，在这种C程序语言中，long与指针是64位，而int是32位。本书假设读者有一定的在某些架构上进行机器级别编程的经验，并将在RISC-V特有的内容出现时加以介绍。 “The RISC-V Reader: An Open Architecture Atlas”是RISC-V的一本有用的参考读物。The user-level ISA [2] 和the privileged architecture [1] 是官方的说明文档。

在完整的计算机中，CPU总是被支持它的硬件围绕，大部分硬件以I/O接口的形式出现。qemu通过“-machine virt”选项模拟了外围硬件，xv6就是为这种硬件开发的。硬件包括RAM，包括boot代码的ROM，连接用户键盘/屏幕的串口以及用于存储的硬盘。

# 2.1 抽象物理资源

读者面对操作系统时，第一个可能想到的问题就是为什么要有一个操作系统？我们可以将图1.2中的系统调用实现在一个应用可以链接的库中。这样一来，每个应用甚至可以拥有按它自己的需求量身定做的库。应用可以直接与硬件资源交互，并采用对应用最好的方式（比方说达到高性能或可预计的性能）来使用硬件资源。一些嵌入式设备的操作系统或实时操作系统通过这样的方式组织。

库方案的缺点在于，如果有一个以上的应用同时运行，这些应用必须妥善地安排。举例来说，每个应用必须周期性地放弃CPU以便其他应用运行。如果所有应用之间相互信任且都没有bug，这种协作式的时间共享方案可能是OK的。然而更典型的场景是，应用之间无法相互信任，而且会有bug，所以我们通常需要比协作式方案提供更强的隔离。

为达到强隔离，以下的方法行之有效，禁止应用直接访问敏感的硬件资源，将资源抽象为服务。举例来说，Unix应用与存储仅仅通过文件系统的open，read，write和close系统调用来交互，而不是直接读写硬盘。这为应用提供了路径名的便利，也使得操作系统（接口的实现者）可以管理硬盘。即使不考虑隔离，有意交互（或者仅仅是希望互相之间不碍事）的程序也更容易发现，相比直接使用硬盘来说，文件系统是一种更方便的抽象。

相似的，Unix透明地在进程之间切换硬件CPU，在必要的时候保存和恢复寄存器状态，从而使得应用感觉不到时间共享。这种透明使得操作系统可以共享CPU，即使有些应用正在无限循环。

另一个例子是Unix进程使用exec来建立他们的内存镜像，而不是直接与物理内存交互。这让操作系统决定将进程放在内存中的哪个位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在硬盘上。Exec也为用户提供了在文件系统中存储可执行程序镜像的便利。

Unix进程之间的很多交互形式通过文件描述符实现。文件描述符不仅从很多细节当中抽象出来（例如，管道或文件中的数据存储在哪里），也定义了一种简化交互的方法。举例来说，如果管道一段的应用执行失败，内核会向管道另一端的进程发送一个EOF信号。

图1.2中的系统调用接口经过了精心地设计，既能够为程序员提供便利，也能够提供强隔离的可能性。Unix接口并不是抽象资源的唯一方法，但事实证明它是非常好的一种。
