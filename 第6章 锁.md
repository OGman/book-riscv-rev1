包括xv6在内的大部分内核，都交替执行不同的活动。交替执行的一个来源是多处理器硬件：计算机中有多个CPU独立执行，例如xv6的RISC-V。多CPU共享物理RAM，xv6利用共享，维护所有CPU都需要读写的数据结构。这种共享提高了一个CPU在更新一个数据结构到一半时，另一个CPU读取它的可能性。也提高了多个CPU同时更新同一个数据的可能性。没有仔细的设计，这种并行访问很可能导致错误的结果或者造成数据结构的破坏。即使是单处理器，内核也可能在不同线程之间切换CPU，导致它们的执行相互交替。最后还有一种情况，当设备终端handler与被打断的代码修改相同数据，如果中断在错误的时间出现，就可能造成数据的破坏。并行指的是多条指令流相互交替执行的情况，原因可以是多处理器、线程切换或者中断。

内核中充满了并发访问的数据。举个例子，两个CPU可以同时调用kalloc，一次同时从空闲页链表头部弹出页。内核设计者喜欢高并发，因为这样能通过并行获取更高的性能，同时也能够提升响应性能。然而，这样做的结果是，内核设计者们必须付出很多努力，来保证并发之下的正确性。有很多方法能写出正确的并发代码，有些比别的更容易理解。保证并发之下正确的策略与支持它们的抽象被称为并发控制技术。

xv6在不同的情境之下，使用多种并发控制技术；可以用的还用更多。本章主要介绍一种广泛使用的技术：锁。锁提供了互斥性（mutual exclusion, mutex就这么来的），保证在同一时间只有一个CPU持有这把锁。如果程序员将每个共享数据项关联一把锁，代码在使用一个项的时候总是持有关联的锁，那就能保证这个数据项在同一时间只被一个CPU使用。在这种情况下，我们就说锁保护了这个数据项。尽管锁是一种容易理解的并发控制机制，但它的缺点在于，它的使用会降低性能，因为从本质上说，锁把并行操作串行化了。

本章的其他部分解释了为什么xv6需要锁，xv6怎样实现锁，以及怎样使用锁。

interleave  simultaneously  concurrency  parallelism  mutual exclusion

# 6.1 竞态条件

为了阐明为什么我们需要锁，我们来看一个例子，在不同CPU上运行的两个进程都调用了wait。wait释放了子进程的内存。因此，在每个CPU上，内核都会调用kfree来释放子进程的页。内核分配器维护着一个链表：kalloc()（kernel/kalloc.c:69）从空闲页链表中弹出一页内存，而kfree()（kernel/kalloc.c:47）向链表中推入一个空闲页。为了达到最佳性能，我们可能会希望两个父进程能并发执行，而不需要等待对方，但是这种想法在xv6的kfree实现下可能是不对的。

图6.1更详细地展现了整个背景：两个CPU共享链表所在的内存，并使用load和store指令操作它。（在现实中，CPU有各自的缓存，但概念上讲，多处理器系统的运行看起来就好像有一整块共享的内存。）如果没有并发请求，你可以像下面这样实现链表的push操作：

```C
struct element {
  int data;
  struct element *next;
};

struct element *list = 0;

void
push (int data)
{
  struct element *l;
  
  l = malloc(sizeof *l);
  l->data = data;
  l->next = list;
  list = l;
}
```

这种实现如果单独执行是没问题的。然而如果同时不止一个拷贝在执行就会出问题。如果两个CPU同时执行push，可能两边都在执行第15行，如图6.1，在两边执行16行之前，就出现了错误的输出，如图6.2所示。在之前的list值前面，next设置了两个链表元素。当16行中对两边list的赋值一旦发生，第二个将会覆盖第一个的值，而第一个中所分配的元素将会丢失。

16行所发生的丢失更新就是竞争条件的一个例子。竞争条件说的就是下面的情况，当一个内存地址被并行访问且其中至少一个访问是写。竞争常常是bug的标志，可能是一次丢失的更新（如果访问都是写），也可能是读取未完全更新的数据结构。竞争的结果取决于参与的两个CPU的精确时间，以及它们的内存操作被内存系统安排的顺序。这都使得包含竞争的问题难以复现和调试。举例来说，当调试push时添加打印语句可能会改变执行的时间，从而导致竞争消失。

防止竞争的常用手段就是上锁。锁保证了互斥，从而使得同一时间只有一个CPU能执行push中的敏感行；这就防止了上面场景的出现。上面代码的正确上锁版本仅仅加了几行（黄色高亮标注）：
```C
struct element *list = 0;
struct lock listlock;

void
push(int data)
{
  struct element *l;
  l = malloc(sizeof *l);
  l->data = data;
  acquire(&listlock);
  l->next = list;
  list = l;
  release(&listlock);
}
```
acquire与release之间的指令通常被称作临界区域。上锁的动作通常称为保护链表。


critical section  invariants  with respect to
