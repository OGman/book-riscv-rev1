xv6有两种锁：自旋锁和睡眠锁。我们从自旋锁讲起。xv6使用spinlock结构体表示自旋锁。结构体中重要的域是locked，当锁可以获取时值为0，当锁被持有时非0。逻辑上讲，xv6应该使用以下的代码来获取锁：

```C
void
acquire(struct spinlock *lk) // does not work!
{
  for (;;) {
    if (lk->locked == 0) {
      lk->locked = 1;
      break;
    }
  }
}
```

不幸的是，这种实现无法保证多处理器下的互斥。两个CPU可能同时到达第25行，发现lk->locked是0，然后都会执行26行，获取到锁。此时，两个不同的CPU都持有了这把锁，这就违背了互斥性。我们需要一种方法来让第25、26行执行为一个原子（即无法分割）步。

因为锁被广泛使用，多处理器通常会提供指令能够实现25、26行的原子版本。在RISC-V上，这个指令时amoswap r，a.amoswap读取内存地址a的值，向那个地址写入寄存器r的内容，然后将再将读到的值放入r。就是说，它交换了寄存器和内存地址的值。它原子地执行这个序列，使用特殊的硬件来阻止其他CPU在读写中间使用这个内存地址。

xv6的`acquire`（kernel/spinlock.c:22）使用可移动的C库函数`__sync_lock_test_and_set`，函数本质上用了`amoswap`指令；返回值是lk->locked中的旧（被交换的）值。acquire函数把这个交换放在循环中，一直重试直到获取到锁。每个循环都会用1与lk->locked交换，然后检查之前的值；如果之前值为0，那我们就拿到了锁，交换也已将lk->locked设置为1。如果之前的值为1，那有其他的CPU正持有这把锁，我们将1与lk->locked交换并不会改变它的值。

一旦获取到锁，acquire记录下哪个CPU拿到了锁，这个信息用于调试。lk->cpu域被锁保护起来，只有持有锁才能修改。

release（kernel/spinlock.c:47）是aquire的反面：它清除lk->cpu域然后释放锁。概念上讲，释放锁只需要将0赋值给lk->locked。C标准允许编译器使用不同的store指令实现赋值，因此C赋值对并行代码来说可能是非原子操作。因此release使用C库函数`__sync_lock_release`，它实现了原子赋值。这个函数归根到底同样调用了一个RISC-V amoswap指令。

wraps  boils down to

