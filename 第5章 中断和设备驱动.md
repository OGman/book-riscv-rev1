驱动，是操作系统中管理特定设备的代码：它注册设备硬件，告诉设备执行操作，处理结果中断，并与可能在等待设备I/O的进程通信。驱动代码可能有很多小花招，因为驱动与它管理的设备协同执行。此外，驱动必须理解设备的硬件接口，这些接口可能很繁琐而且缺乏文档。

需要操作系统关注的设备通常在操作系统中注册，以生成中断，中断是trap的一种。内核trap处理代码识别到设备产生中断后，调用驱动的中断handler；在xv6中，这个分发过程在devintr(kernel/tarp.c:177)中。

很多设备驱动在两种上下文中执行代码：上半段运行在进程的内核线程中，下半段在中断时刻执行。上半段被read，write之类的系统调用所调用，来让设备执行I/O操作。这些代码可能请求硬件开始一项操作（例如，请求硬盘读一个块）；然后等待操作完成。最终设备完成了操作，触发中断。设备的中断handler，扮演下半段角色，指出是什么操作已经完成，然后唤醒相应的等待进程，接着告诉硬件开始为执行下一项等待中的操作。

concurrently

# 5.1 代码：控制台输入

控制台驱动（console.c）是驱动结构的一个简单例子。控制台驱动通过RISC-V附带的UART串口硬件接收人类打印的字符。控制台驱动每次积累一行的输入，处理特殊字符例如backspace和ctrl-u。用户进程，例如shell，使用read系统调用，来抓取控制台的输入行。当你在QEMU中向xv6输入时，你的按键通过QEMU的模拟UART硬件传递到xv6。

跟驱动交互的UART硬件QEMU模拟的一块16550芯片。在真实计算机上，16550能管理连接到终端或其他计算机的RS232串口。当运行QEMU时，它连接到你的键盘和显示器上。

UART硬件对软件来说就是一组映射在内存上的控制寄存器。就是说，RISC-V硬件上的一些物理地址连接到UART设备，所以在这些地址上加载和保存是跟设备硬件交互，而不是RAM。UART内存映射地址从0x10000000开始，或UART0（kernel/memlayout.h:21）。有一些UART控制寄存器，每个都有1字节的宽度。它们到UART0的偏离被定义在（kernel/uart.c:22）。举例来说，LSR寄存器中包含的位，表示输入的字符是否正等待被软件读取。这些字符（如果有的话）可以被RHR寄存器读取。每读到一个，UART硬件就将它从内部的等待字符FIFO队列中删除，当FIFO队列被清空，硬件会清掉LSR中的“就绪”位。UART的传输硬件基本上与接收硬件独立；如果软件向THR写入一个字节，UART将发送它。

xv6的main函数调用consoleinit（kernel/console.c:184）来初始化UART硬件。这段代码注册UART，当UART每接收到一个字节的输入时，产生一个接收中断，UART每次发送完一个字节的输出时，产生一个发送完毕中断（kernel/uart.c:53）。

xv6 shell通过init.c（user/init.c:19）所打开的文件描述符从控制台读取内容。对read系统调用的调用通过kernel调到consoleread（kernel/console.c:82）。consoleread等待输入到来（从中断）并在cons.buf缓存，然后将输入草被盗用户空间，接着（在一整行都到达后）返回到用户进程中。如果用户还没有键入一整行，任何读取进程将在sleep调用（kernel/console.c:98）中等待（第7章详细解释了sleep的细节）。

当用户输入一个字节，UART硬件请求RISC-V产生一个中断，这将激活xv6的trap handler。trap handler调用devintr（kernel/trap.c:177），它会查看RISC-V的scause寄存器来获知中断来自于一个外部设备。然后它请求一个叫做PLIC的硬件单元来告诉它那个设备产生了中断（kernel/trap.c:186）。如果是UART，devintr调用uartintr。

uartintr（kernel/uart.c:180）从UART硬件读取任何等待输入的字节，然后将它们传给consoleintr（kernel/console.c:138）；它不会等待字符，因为未来的输入将产生新的中断。consoleintr的工作是在cons.buf中积累输入字符直到形成一个完整的行。consoleintr对回退与一些别的字符特别对待。当新行形成时，consoleintr唤醒等待的consoleread（如果有的话）。

一旦被唤醒，consoleread将在cons.buf中看到一个完整的行，将它拷贝到用户空间，然后（通过系统调用机制）返回到用户空间。

keystrokes

# 5.2 代码：控制台输出

连接到控制台的文件描述符执行write系统调用，最终会到达uartputc（kernel/uart.c:87）。设备驱动维护一个输出缓冲区（uart_tx_buf），这样写入进程就不需要等待UART完成发送；uartputc将每个字符添加到缓冲区，调用uartstart来启动设备发送（如果还没启动），然后返回。uartputc需要等待的唯一情况是缓冲区已满。

UART每完成一字节的发送都会产生一个中断。uartintr调用uartstart来检查设备是否完成了发送，然后把下一个缓冲中的输出字符传给设备。因此，如果一个进程向控制台写了很多字节，一般而言，第一个字节会被uartputs调用的uartstart所传递，剩余的缓存区字节将被传输完成中断中的uartintr调用的uartstart发送。

需要注意的一般模式是通过缓冲和中断将设备活动与进程活动解耦。即使在没有进程等待读取的时候，控制台驱动也可以执行输入；后续的读取将看到这个输入。相似地，进程不需要等待设备就能发送输出数据。通过允许进程与设备I/O协同运行，这种解耦能够提升性能。另外，这种解耦在低速设备（比方UART）且需要即时反馈时（例如显示输入的字符）非常重要。这种方式有时称为I/O concurrency。

concurrently

# 5.3 驱动中的并行

你可能已经注意到，在consoleread函数和consoleintr函数中会调用acquire。这些调用获取到一把锁，这把锁保护控制台驱动的数据结构不会被并行访问所干扰。这里有三种并发的危险：在不同CPU上执行的两个进程可能同时调用consoleread；当CPU已经执行在consoleread中时，硬件可能请求这个CPU传递一个控制台（实际是UART）中断；硬件也可能在CPU执行consoleread时，请求另一个CPU传递控制台中断。第6章探索了锁如何在这些场景中发挥作用。

