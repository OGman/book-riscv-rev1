任何操作系统都有可能运行比CPU数更多的进程，所以需要对如何在进程之间分享CPU时间进行妥善安排。理想的共享应该对用户进程透明。常用的方法是在硬件CPU上复用进程，给每个进程都呈现一种假象，它拥有它自己的虚拟CPU。这一章阐述了xv6怎样实现这样的复用。

likely  illusion

# 7.1 复用

xv6中，有两种情况下，会将CPU从一个进程切换到另一个进程，从而实现复用。第一种，当进程等待设备或管道I/O完成，或等待子进程退出，或者在sleep系统调用中等待时，xv6的sleep与wakeup机制会进行切换。第二种，xv6周期性地强制切换，来处理长时间计算而不进行睡眠的进程。这种复用制造了每个进程有自己CPU的假象，正如xv6使用内存分配器和硬件页表来制造每个进程有自己的内存的假象一样。

实现复用提出了一些挑战。首先，如何从一个进程切换到另一个进程？虽然切换上下文的想法看起来很简单，但它的实现是xv6最为晦涩难懂的代码之意。其次，怎样用一种对用户进程透明的方法来强制切换？xv6使用标准技术，使用计时器中断来驱动上下文切换。第三，很多CPU可能同时在进程间切换，因此有必要制定一个锁方案来避免竞争。第四，进程的内存和其他资源必须在进程退出时释放，但进程无法独立完成所有，（例如）它不能释放自己还在被使用的内核栈。第五，多核机器的每个核必须记住正在运行的进程，这样系统调用才能操作正确进程的内核状态。最后，sleep和wakeup允许进程在等待某个事件时放弃CPU，进入睡眠，也允许别的进程唤醒之前的进程。需要注意避免竞争，不然会导致唤醒通知的丢失。xv6试着尽可能简单地解决这些问题，然而最后的代码却充满了小技巧。

opaque  nevertheless

# 7.2 代码：上下文切换

图7.1描绘了从一个用户进程切换到另一个所包含的步骤：一个用户-内核转换（系统调用或中断）到老进程的内核线程，上下文切换到当前CPU的调度线程，一个上下文切换到新进程的内核线程，一个trap返回用户层进程。xv6调度器在每个CPU上有一个专用的线程（保存的寄存器和栈），因为调度器在老进程的内核栈上运行并不安全。别的CPU核可能唤醒这个线程并运行它，在两个不同的CPU上使用同一个栈可能是灾难性的。在这个部分中，我们将研究内核线程和调度线程之间的切换机制。

从一个线程切换到另一个线程包括保存旧线程的CPU寄存器，恢复之前保存的新线程的寄存器；栈指针和程序计数器都要被保存和恢复，这说明CPU将会切换栈，并切换正在执行的代码。

swtch函数执行了内核线程切换中的保存和恢复。swtch不直接了解线程；它只是保存和恢复寄存器集合，又叫上下文。当进程需要让出CPU时，进程的内核线程调用swtch来保存自己的上下文，返回到调度器的上下文中。每个上下文的包含在context结构体中（kernel/proc.h:2），context结构体本身又被包含在进程的proc结构体或者CPU的cpu结构体中。swtch有两个参数：`struct context *old`与`struct context *new`。它把当前的寄存器保存在old中，从new中加载寄存器，然后返回。

我们来跟踪一个进程切换到调度器的过程。在第4章中我们看到一种可能性，在中断的最后，usertrap会调用yield。yield然后调用了sched，sched会调用swtch来将当前的上下文保存在p->context中，然后切换到之前保存在cpu->scheduler（kernel/proc.c:509）中的调度器上下文。

swtch（kernel/swtch.S:3）仅保存了被调者保存的寄存器；调用者保存的寄存器通过调用C代码保存在栈上（如果需要）。swtch知道context结构体中每个寄存器域的偏移。它不保存程序计数器，而是保存ra寄存器，ra记录了swtch被调用位置的返回地址。现在swtch开始从新上下文中恢复寄存器，其中的寄存器值是上一个swtch所保存的。当swtch返回时，它返回到恢复的ra寄存器所指向的指令。补充一下，它返回到新线程的栈上。

在我们的例子中，sched调用swtch来向cpu->scheduler切换，这是每个CPU的调度器上下文。这个上下文在调度器调用swtch时被保存（kernel/proc.c:475）。当我们追踪的swtch返回时，它不是返回到sched而是返回到scheduler中，而且它的栈指针指向当前CPU的调度器栈。

dedicated

# 7.3 代码：调度

上个部分研究了swtch的底层细节；现在我们将swtch视为已知，研究从一个进程的内核线程通过角度器切换到另一个进程的过程。调度器在每个CPU上以一种特殊线程的形式存在，每个都在执行scheduler函数。这个函数负责挑选下一个运行的进程。想要让出CPU的进程必须获取到自己的进程锁p->lock，释放持有的其他锁，更新自己的状态（p->state），然后调用sched。yield（kernel/proc.c:515）遵循这个习惯，与sleep和exit一样，这两个函数我们会在后面讲到。sched两次检查这些条件，然后是一个这些条件隐含的条件：因为持有锁，中断一定是被禁止的。最后，sched调用swtch来将当前的上下文保存在p->context中，切换到cpu->scheduler中的调度器上下文。swtch返回到调度器的栈，类似调度器的swtch之前的返回。调度器继续for循环，找到一个要运行的进程，切换过去，不断重复这个周期。

我们刚刚看到，xv6在调用swtch过程中持有p->lock：swtch的调用者必须已经持有这把锁，而且锁的控制权传递给了切换到的代码。这个惯例对所来说并不常见；通常获取锁的线程也要负责释放锁，这样更容易判断是否正确。在上下文切换中必须打破这个惯例，因为p->lock所保护的进程中的state和context上的不变量在swtch执行过程中是不正确的。有一个例子可以说明swtch过程中未持有p->lock会引发的问题：另一个CPU可能决定在yield后运行这个进程，将他的state设置为RUNNABLE，但在之前，swtch已经让进程停止使用自己的内核栈。结果是，两个CPU运行在同一个栈上，这是不可能正确的。

一个内核线程通常在sched中让出CPU，而且通常会切换到调度器中的同一个位置，调度器几乎总是切换到之前调用了sched的内核线程中。因此，如果在xv6切换线程的地方打印行号，将会看到一直是同一种简单的模式：（kernel/proc.c:475），（kernel/proc.c:509），（kernel/proc.c:475），（kernel/proc.c:509），等等等。


in charge of   as though   convention      makes it easier to reason about correctness    coroutines

